<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>BeautifulDinajpur Poster Builder</title>
<style>
  :root{
    --bg:#111418; --panel:#1b2030; --panel-2:#23293a; --text:#e9eef5;
    --accent:#6ea8fe; --muted:#a9b2c7;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column; align-items:center;
  }
  h2{font-weight:700; letter-spacing:.3px; margin:14px 12px 6px}
  #app{
    width:min(100vw,640px);
    display:flex; flex-direction:column; gap:8px; padding:8px;
  }
  /* Canvas area */
  #canvas-wrap{
    position:relative; border-radius:16px; overflow:hidden;
    background:#000; box-shadow:0 8px 24px rgba(0,0,0,.35);
    touch-action:none;
    will-change: transform;
  }
  canvas{ width:100%; height:auto; display:block; image-rendering: -webkit-optimize-contrast; }
  /* Floating text action icons */
  #textIcons{
    position:absolute; display:none; gap:4px; z-index:5;
    transform:translate(-50%,-100%);
  }
  #textIcons button{
    border:none; outline:none; border-radius:8px;
    padding:6px 8px; font-size:14px; line-height:1;
    background:var(--panel-2); color:var(--text);
    box-shadow:0 4px 14px rgba(0,0,0,.35);
  }
  #textIcons button:active{ transform:scale(.98); }
  #textIcons input[type="color"] {
    width:20px; height:20px; padding:0; border:none; outline:none;
    border-radius:4px; cursor:pointer; background:transparent;
  }
  #textIcons select {
    font-size:12px; padding:2px 4px; background:var(--panel-2); color:var(--text);
    border:none; outline:none; border-radius:4px; min-width:60px;
  }
  #textIcons input[type="checkbox"] {
    width:16px; height:16px; accent-color: var(--accent);
  }
  /* Floating image action icons */
  #imageIcons{
    position:absolute; display:none; gap:4px; z-index:5;
    left:50%; top:20px; transform:translateX(-50%);
  }
  #imageIcons button{
    border:none; outline:none; border-radius:8px;
    padding:6px 8px; font-size:14px; line-height:1;
    background:var(--panel-2); color:var(--text);
    box-shadow:0 4px 14px rgba(0,0,0,.35);
  }
  #imageIcons button:active{ transform:scale(.98); }
  /* Crop mode overlay */
  #cropOverlay{
    position:absolute; top:0; left:0; width:100%; height:100%;
    background:rgba(0,0,0,0.5); display:none; z-index:10;
    cursor:crosshair;
  }
  #cropCanvas{ position:absolute; top:0; left:0; width:100%; height:100%; }
  /* Top controls - Compact version */
  #controls{
    background:var(--panel); border-radius:12px; padding:6px;
    display:flex; flex-direction:column; gap:6px;
  }
  #controls input[type="text"]{
    width:100%;
  }
  #controls input[type="file"],
  #controls input[type="text"],
  #controls select,
  #controls button{
    border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:14px; background:var(--panel-2); color:var(--text);
    min-height:44px;
    -webkit-tap-highlight-color: transparent;
  }
  #controls button.primary{ background:var(--accent); color:#0b1020; font-weight:700; }
  #sourceGroup {
    display:flex; flex-wrap:wrap; gap:6px; align-items:center;
  }
  #sourceGroup input[type="color"] { flex:1; padding:4px; min-width:60px; }
  #sourceGroup select { flex:2; min-width:100px; }
  #sourceGroup .small-btn {
    padding:4px 6px; font-size:12px; min-width:30px;
  }
  #sourceGroup label {
    display:flex; align-items:center; gap:4px; font-size:12px; white-space:nowrap;
  }
  .row {
    display: flex; gap: 6px; align-items: center; flex-wrap:wrap;
  }
  .row input[type="file"], .row select {
    flex: 1; min-width:120px;
  }
  .headline-row {
    display: flex; gap: 6px; align-items: center; flex-wrap:wrap;
  }
  .headline-row input[type="text"] {
    flex: 1; min-width: 120px;
  }
  /* Bottom controls - Slightly compact */
  #bottom-controls{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    background:var(--panel); border-radius:12px; padding:6px;
    flex-wrap: wrap;
  }
  #bottom-controls .group{ display:flex; gap:6px; }
  .btn{
    border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:16px; background:var(--panel-2); color:var(--text);
    min-width:44px; min-height:44px; text-align:center;
    -webkit-tap-highlight-color: transparent;
  }
  .btn.primary{ background:var(--accent); color:#0b1020; font-weight:700; }
  #zoomPercent{ color:var(--muted); font-weight:600; font-size:14px; }
  /* Selection dropdown */
  #itemSelect {
    background:var(--panel-2); color:var(--text); border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:14px; min-width:120px; min-height:44px;
  }
  /* Selected badge (optional hint) */
  #selectedBadge{
    position:absolute; left:50%; top:8px; transform:translateX(-50%);
    background:rgba(110,168,254,.18); color:#cfe0ff;
    padding:12px 12px; border-radius:999px; font-size:13px;
    pointer-events:none; display:none; z-index:4;
  }
  /* Source input */
  #sourceInput {
    margin-top: 0;
  }
  /* Media Queries for Responsiveness */
  @media (max-width: 480px) {
    #app { padding: 4px; gap: 4px; }
    #controls { padding: 4px; gap: 4px; }
    #bottom-controls { padding: 4px; gap: 4px; }
    #sourceGroup { flex-direction: column; align-items: stretch; }
    .row, .headline-row { flex-direction: column; align-items: stretch; }
    .btn, #controls input[type="file"], #controls input[type="text"], #controls select, #itemSelect { font-size: 16px; padding: 12px; min-height: 48px; }
    #sourceGroup .small-btn { min-width: 40px; min-height: 40px; }
    #textIcons, #imageIcons { gap: 2px; }
    #textIcons button, #imageIcons button { padding: 4px 6px; font-size: 12px; }
    canvas { max-height: 50vh; }
  }
  @media (max-width: 320px) {
    #zoomPercent { font-size: 12px; }
    .btn { min-width: 36px; min-height: 36px; font-size: 14px; padding: 6px; }
    #app { padding: 2px; gap: 2px; }
  }
  @media (min-width: 768px) {
    #app { max-width: 640px; margin: 0 auto; }
    canvas { max-height: 60vh; }
  }
</style>
</head>
<body>
  <h2>BeautifulDinajpur Poster Builder</h2>
  <div id="app">
    <!-- Canvas Area -->
    <div id="canvas-wrap">
      <canvas id="poster"></canvas>
      <div id="selectedBadge">Selected</div>
      <div id="textIcons">
        <button id="moveTextBtn" title="Free Transform">‚ÜîÔ∏è</button>
        <button id="duplicateBtn" title="Duplicate Text">üìã</button>
        <button id="editBtn" title="Edit text">‚úèÔ∏è</button>
        <input type="color" id="selectedColor" title="Change color" />
        <select id="selectedFont" title="Change font"></select>
        <input type="checkbox" id="textShadow" title="Toggle shadow" checked />
        <button id="textZoomOut" title="Text Zoom Out">-</button>
        <button id="textZoomIn" title="Text Zoom In">+</button>
        <button id="closeText" title="Close Selection">‚úï</button>
        <button id="delBtn" title="Delete text">üóëÔ∏è</button>
      </div>
      <div id="imageIcons">
        <button id="moveImgBtn" title="Free Transform">‚ÜîÔ∏è</button>
        <button id="imgZoomOut" title="Image Zoom Out">-</button>
        <button id="imgZoomIn" title="Image Zoom In">+</button>
        <button id="freeCropBtn" title="Freehand Crop">‚úÇÔ∏è</button>
        <button id="closeImage" title="Close Selection">‚úï</button>
      </div>
      <div id="cropOverlay">
        <canvas id="cropCanvas"></canvas>
      </div>
    </div>
    <!-- Controls - Compact -->
    <div id="controls">
      <div class="row">
        <input type="file" id="uploader" accept="image/*" multiple />
        <select id="itemSelect">
          <option value="">‡¶ï‡ßã‡¶® ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®</option>
        </select>
      </div>
      <div class="headline-row">
        <input type="text" id="textInput" placeholder="‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (headline / caption)" />
        <button id="addText" class="primary">+ Add Text</button>
      </div>
      <input type="text" id="sourceInput" placeholder="‡¶§‡¶•‡ßç‡¶Ø‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (‡¶â‡ßé‡¶∏)" />
      <div id="sourceGroup">
        <input type="color" id="sourceColor" value="#ffffff" />
        <select id="sourceFont">
          <option value="sans-serif">Loading fonts...</option>
        </select>
        <label><input type="checkbox" id="sourceShadow" checked /> ‡¶∂‡ßç‡¶Ø‡¶æ‡¶°‡ßã</label>
        <button id="sourceZoomOut" class="small-btn" title="Source Zoom Out">‚Äì</button>
        <button id="sourceZoomIn" class="small-btn" title="Source Zoom In">+</button>
      </div>
    </div>
    <!-- Bottom bar -->
    <div id="bottom-controls">
      <div class="group">
        <button id="zoomOut" class="btn">‚Äì</button>
        <button id="zoomIn" class="btn">+</button>
      </div>
      <div id="zoomPercent">Image Zoom: 100%</div>
      <button id="download" class="btn primary">Download</button>
    </div>
  </div>
<script>
/* ========= Optimized State Management ========= */
const elements = {
  canvas: document.getElementById('poster'),
  ctx: null,
  cropCanvas: document.getElementById('cropCanvas'),
  cropCtx: null,
  uploader: document.getElementById('uploader'),
  textInput: document.getElementById('textInput'),
  sourceInput: document.getElementById('sourceInput'),
  addTextBtn: document.getElementById('addText'),
  sourceColor: document.getElementById('sourceColor'),
  sourceFont: document.getElementById('sourceFont'),
  sourceShadow: document.getElementById('sourceShadow'),
  sourceZoomIn: document.getElementById('sourceZoomIn'),
  sourceZoomOut: document.getElementById('sourceZoomOut'),
  zoomInBtn: document.getElementById('zoomIn'),
  zoomOutBtn: document.getElementById('zoomOut'),
  zoomLabel: document.getElementById('zoomPercent'),
  downloadBtn: document.getElementById('download'),
  itemSelect: document.getElementById('itemSelect'),
  textIcons: document.getElementById('textIcons'),
  imageIcons: document.getElementById('imageIcons'),
  cropOverlay: document.getElementById('cropOverlay'),
  editBtn: document.getElementById('editBtn'),
  delBtn: document.getElementById('delBtn'),
  closeText: document.getElementById('closeText'),
  closeImage: document.getElementById('closeImage'),
  selectedBadge: document.getElementById('selectedBadge'),
  selectedColor: document.getElementById('selectedColor'),
  selectedFont: document.getElementById('selectedFont'),
  textShadow: document.getElementById('textShadow'),
  textZoomIn: document.getElementById('textZoomIn'),
  textZoomOut: document.getElementById('textZoomOut'),
  imgZoomIn: document.getElementById('imgZoomIn'),
  imgZoomOut: document.getElementById('imgZoomOut'),
  freeCropBtn: document.getElementById('freeCropBtn'),
  moveTextBtn: document.getElementById('moveTextBtn'),
  moveImgBtn: document.getElementById('moveImgBtn'),
  duplicateBtn: document.getElementById('duplicateBtn')
};
const state = {
  images: [],
  texts: [],
  previewText: null,
  selected: null,
  selectedType: null,
  selectedImgIndex: -1,
  currentDate: '',
  sourceObj: { text: '', color: '#ffffff', font: 'sans-serif', shadow: true, scale: 1 },
  defaultFont: 'sans-serif',
  defaultHeadlineColor: '#ffffff',
  showHandles: false,
  transformMode: null,
  currentObj: null,
  isCurrentText: false,
  dragStartX: 0, dragStartY: 0,
  startObjX: 0, startObjY: 0,
  startScale: 1,
  startRadial: 0,
  prevAngle: 0,
  lastClickTime: 0,
  lastClickPos: { x: 0, y: 0 },
  DOUBLE_CLICK_THRESHOLD: 300,
  DOUBLE_CLICK_DISTANCE: 10,
  pinchTarget: '',
  pinchStartDist: 0, pinchStartScale: 1,
  pinchCenter: {x:0,y:0},
  imgOffsetFromCenter: {x:0,y:0},
  textPinchStartDist: 0, textPinchStartScale: 1,
  selectedImgPinchStartDist: 0, selectedImgPinchStartScale: 1,
  cropping: false,
  cropPoints: [],
  currentCropImg: null,
  needsRedraw: false,
  redrawTimeout: null,
  textBounds: [],
  lastDrawTime: 0,
  framePadding: 40,
  usableWidth: 0,
  baseFontPx: 48,
  baseLineH: 60,
  MIN_REDRAW_INTERVAL: 16,
  handleRadius: 8,
  rotOffset: 40,
  isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
};
state.MIN_REDRAW_INTERVAL = state.isMobile ? 33 : 16;
/* ========= Frame ========= */
const frame = new Image();
frame.src = 'post.png';
frame.crossOrigin = 'anonymous';
let frameBitmap = null;
/* ========= Context Init ========= */
elements.ctx = elements.canvas.getContext('2d', { willReadFrequently: true, alpha: false });
elements.cropCtx = elements.cropCanvas.getContext('2d');
/* ========= Helpers ========= */
const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
const deviceToCanvas = (px, py) => {
  const r = elements.canvas.getBoundingClientRect();
  return {
    x: (px - r.left) * (elements.canvas.width / r.width),
    y: (py - r.top) * (elements.canvas.height / r.height)
  };
};
const getTouchCanvasPos = (t) => deviceToCanvas(t.clientX, t.clientY);
const getUnscaledDims = (obj, isText) => {
  if (isText) {
    const dims = getWrappedTextDimensions(obj);
    const s = obj.scale;
    return { width: dims.width / s, height: dims.height / s };
  } else {
    return { width: obj.img.width, height: obj.img.height };
  }
};
const isPointInObject = (p, obj, isText) => {
  if (isText) {
    const index = state.texts.indexOf(obj);
    if (index === -1) return false;
    const bound = state.textBounds[index];
    if (!bound) return false;
    return (p.x > bound.x && p.x < bound.x + bound.width &&
            p.y > bound.y && p.y < bound.y + bound.height);
  } else {
    const s = obj.scale;
    const th = obj.rotation;
    const cos = Math.cos(th);
    const sin = Math.sin(th);
    let dx = p.x - obj.x;
    let dy = p.y - obj.y;
    let itx = cos * dx + sin * dy;
    let ity = -sin * dx + cos * dy;
    let local_x = itx / s;
    let local_y = ity / s;
    let unscaled = getUnscaledDims(obj, false);
    let halfUnW = unscaled.width / 2;
    let halfUnH = unscaled.height / 2;
    return Math.abs(local_x) <= halfUnW && Math.abs(local_y) <= halfUnH;
  }
};
const resizeImage = (img, maxWidth, maxHeight, quality = 0.8) => {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  let {width, height} = img;
  if (width > maxWidth || height > maxHeight) {
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    width *= ratio;
    height *= ratio;
  }
  canvas.width = width;
  canvas.height = height;
  ctx.drawImage(img, 0, 0, width, height);
  return canvas.toDataURL('image/jpeg', quality);
};
/* ========= Optimized Redraw ========= */
const scheduleRedraw = () => {
  const now = performance.now();
  if (now - state.lastDrawTime < state.MIN_REDRAW_INTERVAL) return;
  state.needsRedraw = true;
  if (state.redrawTimeout) return;
  state.redrawTimeout = requestAnimationFrame(() => {
    if (state.needsRedraw) {
      draw();
      state.needsRedraw = false;
      state.lastDrawTime = performance.now();
    }
    state.redrawTimeout = null;
  });
};
/* ========= Selection Utils ========= */
const updateSelectedControls = () => {
  if (state.selected && state.selectedType === 'text') {
    elements.selectedColor.value = state.selected.color;
    elements.selectedFont.value = state.selected.font;
    elements.textShadow.checked = state.selected.shadow !== false;
  }
};
const updateSelectionDisplay = () => {
  let badgeText = 'Selected';
  if (state.showHandles) badgeText = 'Free Transform';
  else if (state.selectedType === 'text' && state.selected) badgeText = 'Text Selected';
  else if (state.selectedType === 'image') badgeText = 'Image Selected';
  elements.selectedBadge.textContent = badgeText;
  elements.selectedBadge.style.display = state.selectedType ? 'block' : 'none';
  if (state.selectedType === 'text' && state.selected) {
    elements.textIcons.style.display = 'flex';
    elements.imageIcons.style.display = 'none';
    const rect = elements.canvas.getBoundingClientRect();
    const left = state.selected.x * rect.width / elements.canvas.width;
    const top = state.selected.y * rect.height / elements.canvas.height;
    elements.textIcons.style.left = left + 'px';
    elements.textIcons.style.top = top + 'px';
    updateSelectedControls();
  } else if (state.selectedType === 'image') {
    elements.imageIcons.style.display = 'flex';
    elements.textIcons.style.display = 'none';
    if (state.selectedImgIndex !== -1) {
      const imgObj = state.images[state.selectedImgIndex];
      const rect = elements.canvas.getBoundingClientRect();
      const left = imgObj.x * rect.width / elements.canvas.width;
      const top = imgObj.y * rect.height / elements.canvas.height - 20;
      elements.imageIcons.style.left = left + 'px';
      elements.imageIcons.style.top = top + 'px';
    } else {
      elements.imageIcons.style.left = '50%';
      elements.imageIcons.style.top = '20px';
    }
  } else {
    elements.textIcons.style.display = 'none';
    elements.imageIcons.style.display = 'none';
  }
  updateItemSelectOptions();
};
const updateItemSelectOptions = () => {
  elements.itemSelect.innerHTML = '<option value="">‡¶ï‡ßã‡¶® ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®</option>';
  state.texts.forEach((t, i) => {
    const opt = document.createElement('option');
    opt.value = `text-${i}`;
    opt.textContent = `‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü: ${t.text.substring(0, 20)}${t.text.length > 20 ? '...' : ''}`;
    elements.itemSelect.appendChild(opt);
  });
  state.images.forEach((img, i) => {
    const opt = document.createElement('option');
    opt.value = `image-${i}`;
    opt.textContent = `‡¶á‡¶Æ‡ßá‡¶ú ${i + 1}`;
    elements.itemSelect.appendChild(opt);
  });
};
/* ========= Fonts ========= */
async function loadFonts() {
  const cacheKey = 'fontList';
  const cached = localStorage.getItem(cacheKey);
  const now = Date.now();
  const cacheExpiry = 24 * 60 * 60 * 1000;
  let data;
  if (cached) {
    const { timestamp, files } = JSON.parse(cached);
    if (now - timestamp < cacheExpiry) {
      data = { files };
      console.log('Loaded fonts from cache');
    }
  }
  if (!data) {
    try {
      const response = await fetch('https://raw.githubusercontent.com/prodhan2/beautifulDinajpurFrames/main/font/file_list.json');
      data = await response.json();
      localStorage.setItem(cacheKey, JSON.stringify({ timestamp: now, files: data.files }));
      console.log('Fetched and cached fonts');
    } catch (error) {
      console.error('Failed to load fonts:', error);
      data = { files: [] };
    }
  }
  const files = data.files || [];
  if (files.length === 0) {
    console.warn('No fonts found');
    return;
  }
  const style = document.createElement('style');
  style.id = 'dynamic-fonts';
  let css = '';
  files.forEach(filename => {
    const fontFamily = filename.replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'unknown';
    const url = `https://raw.githubusercontent.com/prodhan2/beautifulDinajpurFrames/main/font/${filename}`;
    css += `@font-face { font-family: '${fontFamily}'; src: url('${url}') format('truetype'); font-weight: normal; font-style: normal; font-display: swap; }`;
  });
  style.textContent = css;
  document.head.appendChild(style);
  const options = ['<option value="sans-serif">Sans-serif</option>'];
  files.forEach(filename => {
    const fontFamily = filename.replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'unknown';
    const displayName = filename.replace(/\.TTF$/i, '');
    options.push(`<option value="${fontFamily}">${displayName}</option>`);
  });
  const optHtml = options.join('');
  elements.selectedFont.innerHTML = optHtml;
  elements.sourceFont.innerHTML = optHtml;
  if (files.length > 0) {
    state.defaultFont = files[0].replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'sans-serif';
    elements.selectedFont.value = state.defaultFont;
    elements.sourceFont.value = state.defaultFont;
    state.sourceObj.font = state.defaultFont;
  }
  console.log('Fonts loaded:', files.length);
}
/* ========= Date ========= */
const getBengaliDate = () => {
  const now = new Date();
  const day = now.getDate();
  const month = now.getMonth();
  const year = now.getFullYear();
  const bengaliMonths = [
    '‡¶ú‡¶æ‡¶®‡ßÅ‡¶Ø‡¶º‡¶æ‡¶∞‡¶ø', '‡¶´‡ßá‡¶¨‡ßç‡¶∞‡ßÅ‡¶Ø‡¶º‡¶æ‡¶∞‡¶ø', '‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö', '‡¶è‡¶™‡ßç‡¶∞‡¶ø‡¶≤', '‡¶Æ‡ßá', '‡¶ú‡ßÅ‡¶®',
    '‡¶ú‡ßÅ‡¶≤‡¶æ‡¶á', '‡¶Ü‡¶ó‡¶∏‡ßç‡¶ü', '‡¶∏‡ßá‡¶™‡ßç‡¶ü‡ßá‡¶Æ‡ßç‡¶¨‡¶∞', '‡¶Ö‡¶ï‡ßç‡¶ü‡ßã‡¶¨‡¶∞', '‡¶®‡¶≠‡ßá‡¶Æ‡ßç‡¶¨‡¶∞', '‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç‡¶¨‡¶∞'
  ];
  const toBengaliDigits = (number) => {
    const bengaliDigits = ['‡ß¶', '‡ßß', '‡ß®', '‡ß©', '‡ß™', '‡ß´', '‡ß¨', '‡ß≠', '‡ßÆ', '‡ßØ'];
    return number.toString().replace(/\d/g, digit => bengaliDigits[parseInt(digit)]);
  };
  return `${toBengaliDigits(day)} ${bengaliMonths[month]} ${toBengaliDigits(year)}`;
};
/* ========= Crop Utils ========= */
let cropStart = {x:0, y:0};
const startCrop = (e) => {
  const p = deviceToCanvas(e.clientX, e.clientY);
  cropStart = p;
  state.cropPoints.push(p);
  drawCrop();
};
const drawCrop = (e) => {
  if (!state.cropping) return;
  const p = deviceToCanvas(e.clientX, e.clientY);
  elements.cropCtx.clearRect(0, 0, elements.cropCanvas.width, elements.cropCanvas.height);
  elements.cropCtx.drawImage(elements.canvas, 0, 0);
  if (state.cropPoints.length > 0) {
    elements.cropCtx.beginPath();
    elements.cropCtx.moveTo(state.cropPoints[0].x, state.cropPoints[0].y);
    state.cropPoints.forEach(pt => elements.cropCtx.lineTo(pt.x, pt.y));
    elements.cropCtx.lineTo(p.x, p.y);
    elements.cropCtx.strokeStyle = 'red';
    elements.cropCtx.lineWidth = 2;
    elements.cropCtx.stroke();
  }
};
const endCrop = (e) => {
  const finalP = deviceToCanvas(e.clientX, e.clientY);
  state.cropPoints.push(finalP);
  if (state.cropPoints.length < 3) {
    state.cropPoints.pop();
    return;
  }
  const obj = state.currentCropImg;
  const s = obj.scale;
  const th = obj.rotation;
  const cos = Math.cos(th);
  const sin = Math.sin(th);
  const w = obj.img.width;
  const h = obj.img.height;
  const polyPoints = state.cropPoints.map(p => {
    let dx = p.x - obj.x;
    let dy = p.y - obj.y;
    let itx = cos * dx + sin * dy;
    let ity = -sin * dx + cos * dy;
    let local_x = itx / s;
    let local_y = ity / s;
    let imageX = local_x + w / 2;
    let imageY = local_y + h / 2;
    return { x: imageX, y: imageY };
  });
  let minX = Math.min(...polyPoints.map(pt => pt.x));
  let maxX = Math.max(...polyPoints.map(pt => pt.x));
  let minY = Math.min(...polyPoints.map(pt => pt.y));
  let maxY = Math.max(...polyPoints.map(pt => pt.y));
  const bboxW = maxX - minX;
  const bboxH = maxY - minY;
  if (bboxW <= 0 || bboxH <= 0) {
    state.cropPoints = [];
    state.cropping = false;
    elements.cropOverlay.style.display = 'none';
    return;
  }
  const newCanvas = document.createElement('canvas');
  newCanvas.width = bboxW;
  newCanvas.height = bboxH;
  const newCtx = newCanvas.getContext('2d');
  newCtx.translate(-minX, -minY);
  newCtx.save();
  newCtx.beginPath();
  newCtx.moveTo(polyPoints[0].x, polyPoints[0].y);
  for (let i = 1; i < polyPoints.length; i++) {
    newCtx.lineTo(polyPoints[i].x, polyPoints[i].y);
  }
  newCtx.closePath();
  newCtx.clip();
  newCtx.drawImage(obj.img, 0, 0);
  newCtx.restore();
  const croppedDataURL = newCanvas.toDataURL('image/png');
  const newImg = new Image();
  newImg.onload = () => {
    obj.img = newImg;
    obj.x += (bboxW * s / 2 - (w * s / 2));
    obj.y += (bboxH * s / 2 - (h * s / 2));
    obj.scale = s * (Math.min(bboxW / w, bboxH / h));
    scheduleRedraw();
  };
  newImg.src = croppedDataURL;
  state.cropping = false;
  elements.cropOverlay.style.display = 'none';
  state.cropPoints = [];
};
/* ========= Text Dimensions ========= */
const getWrappedTextDimensions = (tb) => {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.font = `700 ${state.baseFontPx}px "${tb.font}"`;
  const maxLocal = state.usableWidth / tb.scale;
  const words = tb.text.split(' ');
  let line = '';
  let lines = [];
  let maxLocalWidth = 0;
  for (let i = 0; i < words.length; i++) {
    const test = line + words[i] + ' ';
    if (tempCtx.measureText(test).width > maxLocal && i > 0) {
      if (line.trim().length) {
        const w = tempCtx.measureText(line).width;
        maxLocalWidth = Math.max(maxLocalWidth, w);
        lines.push(line);
        line = words[i] + ' ';
      } else {
        let piece = '';
        for (const ch of words[i] + ' ') {
          if (tempCtx.measureText(piece + ch).width > maxLocal) {
            const w = tempCtx.measureText(piece).width;
            maxLocalWidth = Math.max(maxLocalWidth, w);
            lines.push(piece);
            piece = ch;
          } else {
            piece += ch;
          }
        }
        const w = tempCtx.measureText(piece).width;
        maxLocalWidth = Math.max(maxLocalWidth, w);
        lines.push(piece);
        line = '';
      }
    } else {
      line = test;
    }
  }
  if (line.trim().length) {
    const w = tempCtx.measureText(line).width;
    maxLocalWidth = Math.max(maxLocalWidth, w);
    lines.push(line);
  }
  const width = maxLocalWidth * tb.scale;
  const height = lines.length * state.baseLineH * tb.scale;
  return { width, height };
};
const updateTextBounds = () => {
  state.textBounds = [];
  state.texts.forEach((tb, index) => {
    const dims = getWrappedTextDimensions(tb);
    state.textBounds.push({
      index,
      x: tb.x - dims.width / 2,
      y: tb.y - dims.height / 2,
      width: dims.width,
      height: dims.height
    });
  });
};
const wrapTextScaled = (ctx, text, x, y, maxWidthWorld, lineHeightWorld, scale) => {
  const maxLocal = maxWidthWorld / scale;
  const lhLocal = lineHeightWorld / scale;
  const oldBaseline = ctx.textBaseline;
  ctx.textBaseline = 'top';
  const words = text.split(' ');
  let line = '';
  let cursorY = y;
  const drawLine = (str) => {
    ctx.fillText(str, x, cursorY);
    cursorY += lhLocal;
  };
  for (let i = 0; i < words.length; i++) {
    const test = line + words[i] + ' ';
    if (ctx.measureText(test).width > maxLocal && i > 0) {
      if (line.trim().length) {
        drawLine(line);
        line = words[i] + ' ';
      } else {
        let piece = '';
        for (const ch of words[i] + ' ') {
          if (ctx.measureText(piece + ch).width > maxLocal) {
            drawLine(piece);
            piece = ch;
          } else {
            piece += ch;
          }
        }
        line = '';
      }
    } else {
      line = test;
    }
  }
  if (line.trim().length) drawLine(line);
  ctx.textBaseline = oldBaseline;
};
/* ========= Optimized Draw ========= */
const draw = () => {
  elements.ctx.clearRect(0, 0, elements.canvas.width, elements.canvas.height);
  // Draw images
  state.images.forEach(imgObj => {
    elements.ctx.save();
    elements.ctx.translate(imgObj.x, imgObj.y);
    elements.ctx.rotate(imgObj.rotation);
    elements.ctx.scale(imgObj.scale, imgObj.scale);
    elements.ctx.drawImage(imgObj.img, -imgObj.img.width / 2, -imgObj.img.height / 2);
    elements.ctx.restore();
  });
  // Frame
  elements.ctx.drawImage(frameBitmap || frame, 0, 0, elements.canvas.width, elements.canvas.height);
  const textShadowBlur = state.isMobile ? 2 : 4;
  const sourceShadowBlur = state.isMobile ? 3 : 6;
  // Date
  if (state.currentDate) {
    elements.ctx.save();
    elements.ctx.textAlign = 'left';
    elements.ctx.textBaseline = 'top';
    elements.ctx.fillStyle = '#ffffff';
    elements.ctx.font = `bold 35px "${state.defaultFont}"`;
    elements.ctx.shadowColor = 'rgba(0,0,0,.65)';
    elements.ctx.shadowBlur = textShadowBlur;
    elements.ctx.fillText(state.currentDate, 30, 30);
    elements.ctx.restore();
  }
  // Source
  if (state.sourceObj.text) {
    elements.ctx.save();
    elements.ctx.textAlign = 'right';
    elements.ctx.textBaseline = 'bottom';
    elements.ctx.fillStyle = state.sourceObj.color;
    elements.ctx.font = `bold ${35 * state.sourceObj.scale}px "${state.sourceObj.font}"`;
    if (state.sourceObj.shadow !== false) {
      elements.ctx.shadowColor = 'rgba(0,0,0,.65)';
      elements.ctx.shadowBlur = sourceShadowBlur;
    } else {
      elements.ctx.shadowColor = 'transparent';
      elements.ctx.shadowBlur = 0;
    }
    elements.ctx.fillText('‡¶∏‡ßã‡¶∞‡ßç‡¶∏: ' + state.sourceObj.text, elements.canvas.width - 30, elements.canvas.height - 110);
    elements.ctx.restore();
  }
  // Texts
  state.texts.forEach(tb => {
    elements.ctx.save();
    elements.ctx.translate(tb.x, tb.y);
    elements.ctx.rotate(tb.rotation);
    elements.ctx.scale(tb.scale, tb.scale);
    elements.ctx.textAlign = 'center';
    elements.ctx.fillStyle = tb.color;
    if (tb.shadow !== false) {
      elements.ctx.shadowColor = 'rgba(0,0,0,.65)';
      elements.ctx.shadowBlur = textShadowBlur;
    } else {
      elements.ctx.shadowColor = 'transparent';
      elements.ctx.shadowBlur = 0;
    }
    elements.ctx.font = `700 ${state.baseFontPx}px "${tb.font}"`;
    wrapTextScaled(elements.ctx, tb.text, 0, 0, state.usableWidth, state.baseLineH, tb.scale);
    elements.ctx.restore();
  });
  // Preview
  if (state.previewText) {
    elements.ctx.save();
    elements.ctx.globalAlpha = 0.7;
    elements.ctx.translate(state.previewText.x, state.previewText.y);
    elements.ctx.rotate(state.previewText.rotation);
    elements.ctx.scale(state.previewText.scale, state.previewText.scale);
    elements.ctx.textAlign = 'center';
    elements.ctx.fillStyle = state.previewText.color;
    if (state.previewText.shadow !== false) {
      elements.ctx.shadowColor = 'rgba(0,0,0,.65)';
      elements.ctx.shadowBlur = textShadowBlur;
    } else {
      elements.ctx.shadowColor = 'transparent';
      elements.ctx.shadowBlur = 0;
    }
    elements.ctx.font = `700 ${state.baseFontPx}px "${state.previewText.font}"`;
    wrapTextScaled(elements.ctx, state.previewText.text, 0, 0, state.usableWidth, state.baseLineH, state.previewText.scale);
    elements.ctx.restore();
  }
  // Selection border and handles
  if (state.selectedType) {
    let obj, isText, halfWW, halfWH, unscaledW, unscaledH, s;
    if (state.selectedType === 'text') {
      obj = state.selected;
      isText = true;
      const dims = getWrappedTextDimensions(obj);
      halfWW = dims.width / 2;
      halfWH = dims.height / 2;
      s = obj.scale;
      unscaledW = dims.width / s;
      unscaledH = dims.height / s;
    } else {
      obj = state.images[state.selectedImgIndex];
      isText = false;
      const iw = obj.img.width;
      const ih = obj.img.height;
      halfWW = iw * obj.scale / 2;
      halfWH = ih * obj.scale / 2;
      s = obj.scale;
      unscaledW = iw;
      unscaledH = ih;
    }
    elements.ctx.save();
    elements.ctx.translate(obj.x, obj.y);
    elements.ctx.rotate(obj.rotation);
    // Border always when selected
    elements.ctx.strokeStyle = 'rgba(110,168,254,0.6)';
    elements.ctx.lineWidth = 2;
    elements.ctx.strokeRect(-halfWW, -halfWH, 2 * halfWW, 2 * halfWH);
    if (state.showHandles) {
      // Corners
      elements.ctx.fillStyle = 'rgba(110,168,254,0.9)';
      const hR = 6;
      const corners = [
        [-halfWW, -halfWH],
        [halfWW, -halfWH],
        [halfWW, halfWH],
        [-halfWW, halfWH]
      ];
      corners.forEach(([cx, cy]) => {
        elements.ctx.beginPath();
        elements.ctx.arc(cx, cy, hR, 0, 2 * Math.PI);
        elements.ctx.fill();
      });
      // Rotation handle
      const rotX = 0;
      const rotY = -halfWH - state.rotOffset;
      elements.ctx.strokeStyle = 'rgba(110,168,254,0.6)';
      elements.ctx.lineWidth = 1;
      elements.ctx.beginPath();
      elements.ctx.moveTo(0, -halfWH);
      elements.ctx.lineTo(rotX, rotY);
      elements.ctx.stroke();
      elements.ctx.fillStyle = 'rgba(110,168,254,0.9)';
      elements.ctx.beginPath();
      elements.ctx.arc(rotX, rotY, hR, 0, 2 * Math.PI);
      elements.ctx.fill();
    }
    elements.ctx.restore();
  }
  updateSelectionDisplay();
};
/* ========= Interaction Utils ========= */
let isDoubleClick = false;
let doubleClickTimeout = null;
const handleClick = (p) => {
  const now = Date.now();
  const timeDiff = now - state.lastClickTime;
  const distDiff = Math.hypot(p.x - state.lastClickPos.x, p.y - state.lastClickPos.y);
  if (timeDiff < state.DOUBLE_CLICK_THRESHOLD && distDiff < state.DOUBLE_CLICK_DISTANCE) {
    isDoubleClick = true;
    clearTimeout(doubleClickTimeout);
    handleDoubleClick(p);
  } else {
    isDoubleClick = false;
    doubleClickTimeout = setTimeout(() => {
      if (!isDoubleClick) {
        handleSingleClick(p);
      }
    }, state.DOUBLE_CLICK_THRESHOLD);
  }
  state.lastClickTime = now;
  state.lastClickPos = p;
};
const handleDoubleClick = (p) => {
  let hitText = false;
  let hitImage = false;
  for (let i = state.texts.length - 1; i >= 0; i--) {
    const bound = state.textBounds[i];
    if (bound && p.x > bound.x && p.x < bound.x + bound.width &&
        p.y > bound.y && p.y < bound.y + bound.height) {
      state.selected = state.texts[i];
      state.selectedType = 'text';
      state.selectedImgIndex = -1;
      state.showHandles = true;
      state.transformMode = null;
      hitText = true;
      updateSelectionDisplay();
      const t = prompt('Edit text:', state.selected.text);
      if (t !== null) {
        state.selected.text = t;
        updateTextBounds();
      }
      scheduleRedraw();
      break;
    }
  }
  if (!hitText) {
    for (let i = state.images.length - 1; i >= 0; i--) {
      if (isPointInObject(p, state.images[i], false)) {
        state.selectedImgIndex = i;
        state.selectedType = 'image';
        state.selected = null;
        state.showHandles = true;
        state.transformMode = null;
        hitImage = true;
        updateSelectionDisplay();
        scheduleRedraw();
        break;
      }
    }
  }
  if (!hitText && !hitImage) {
    state.selected = null;
    state.selectedType = null;
    state.selectedImgIndex = -1;
    state.showHandles = false;
    state.transformMode = null;
    updateSelectionDisplay();
    scheduleRedraw();
  }
};
const handleSingleClick = (p) => {
  let hitSomething = false;
  if (state.showHandles && state.selectedType) {
    const isText = state.selectedType === 'text';
    const obj = isText ? state.selected : state.images[state.selectedImgIndex];
    const s = obj.scale;
    const th = obj.rotation;
    const cos = Math.cos(th);
    const sin = Math.sin(th);
    let dx = p.x - obj.x;
    let dy = p.y - obj.y;
    let itx = cos * dx + sin * dy;
    let ity = -sin * dx + cos * dy;
    let local_x = itx / s;
    let local_y = ity / s;
    const unscaled = getUnscaledDims(obj, isText);
    const halfUnW = unscaled.width / 2;
    const halfUnH = unscaled.height / 2;
    const localHR = state.handleRadius / s;
    const localOffset = state.rotOffset / s;
    const lrx = 0;
    const lry = -halfUnH - localOffset;
    let distRot = Math.hypot(local_x - lrx, local_y - lry);
    if (distRot < localHR) {
      state.transformMode = 'rotate';
      state.prevAngle = Math.atan2(local_y, local_x);
      state.currentObj = obj;
      state.isCurrentText = isText;
      hitSomething = true;
    } else {
      const corners = [
        {lx: -halfUnW, ly: -halfUnH},
        {lx: halfUnW, ly: -halfUnH},
        {lx: halfUnW, ly: halfUnH},
        {lx: -halfUnW, ly: halfUnH}
      ];
      for (let corner of corners) {
        let d = Math.hypot(local_x - corner.lx, local_y - corner.ly);
        if (d < localHR) {
          state.transformMode = 'scale';
          state.startScale = obj.scale;
          state.startRadial = Math.hypot(local_x, local_y);
          state.currentObj = obj;
          state.isCurrentText = isText;
          hitSomething = true;
          break;
        }
      }
    }
    if (!hitSomething) {
      if (Math.abs(local_x) < halfUnW && Math.abs(local_y) < halfUnH) {
        state.transformMode = 'move';
        state.dragStartX = p.x;
        state.dragStartY = p.y;
        state.startObjX = obj.x;
        state.startObjY = obj.y;
        state.currentObj = obj;
        state.isCurrentText = isText;
        hitSomething = true;
      }
    }
  }
  if (!hitSomething) {
    state.selected = null;
    state.selectedType = null;
    state.selectedImgIndex = -1;
    state.showHandles = false;
    state.transformMode = null;
    state.currentObj = null;
    for (let i = state.texts.length - 1; i >= 0; i--) {
      const bound = state.textBounds[i];
      if (bound && p.x > bound.x && p.x < bound.x + bound.width &&
          p.y > bound.y && p.y < bound.y + bound.height) {
        state.selected = state.texts[i];
        state.selectedType = 'text';
        state.selectedImgIndex = -1;
        state.transformMode = 'move';
        state.dragStartX = p.x;
        state.dragStartY = p.y;
        state.startObjX = state.selected.x;
        state.startObjY = state.selected.y;
        state.currentObj = state.selected;
        state.isCurrentText = true;
        state.showHandles = true;
        hitSomething = true;
        break;
      }
    }
    if (!hitSomething) {
      for (let i = state.images.length - 1; i >= 0; i--) {
        if (isPointInObject(p, state.images[i], false)) {
          state.selectedImgIndex = i;
          state.selectedType = 'image';
          state.selected = null;
          state.transformMode = 'move';
          state.dragStartX = p.x;
          state.dragStartY = p.y;
          state.startObjX = state.images[i].x;
          state.startObjY = state.images[i].y;
          state.currentObj = state.images[i];
          state.isCurrentText = false;
          state.showHandles = false;
          hitSomething = true;
          break;
        }
      }
    }
  }
  if (hitSomething) {
    updateSelectionDisplay();
  }
  scheduleRedraw();
};
/* ========= Pointer Events ========= */
elements.canvas.addEventListener('pointerdown', (e) => {
  const p = deviceToCanvas(e.clientX, e.clientY);
  handleClick(p);
  e.preventDefault();
});
elements.canvas.addEventListener('pointermove', (e) => {
  if (!state.transformMode || !state.currentObj || isDoubleClick) return;
  const isText = state.isCurrentText;
  const currentP = deviceToCanvas(e.clientX, e.clientY);
  const s = state.currentObj.scale;
  const th = state.currentObj.rotation;
  const cos = Math.cos(th);
  const sin = Math.sin(th);
  let dx = currentP.x - state.currentObj.x;
  let dy = currentP.y - state.currentObj.y;
  let itx = cos * dx + sin * dy;
  let ity = -sin * dx + cos * dy;
  let local_x = itx / s;
  let local_y = ity / s;
  if (state.transformMode === 'move') {
    const delX = currentP.x - state.dragStartX;
    const delY = currentP.y - state.dragStartY;
    state.currentObj.x = state.startObjX + delX;
    state.currentObj.y = state.startObjY + delY;
  } else if (state.transformMode === 'scale') {
    const currentRadial = Math.hypot(local_x, local_y);
    let newScale = state.startScale * (currentRadial / state.startRadial);
    newScale = clamp(newScale, 0.1, 8);
    state.currentObj.scale = newScale;
    if (isText) updateTextBounds();
  } else if (state.transformMode === 'rotate') {
    const currentAngle = Math.atan2(local_y, local_x);
    const delta = currentAngle - state.prevAngle;
    state.currentObj.rotation += delta;
    state.prevAngle = currentAngle;
  }
  scheduleRedraw();
});
['pointerup','pointerleave','pointercancel'].forEach(ev => {
  elements.canvas.addEventListener(ev, () => {
    state.transformMode = null;
    state.currentObj = null;
    state.isCurrentText = false;
    isDoubleClick = false;
    clearTimeout(doubleClickTimeout);
    scheduleRedraw();
  });
});
/* ========= Touch Events ========= */
elements.canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) return;
  if (e.touches.length === 2) {
    e.preventDefault();
    const p1 = getTouchCanvasPos(e.touches[0]);
    const p2 = getTouchCanvasPos(e.touches[1]);
    const cx = (p1.x + p2.x) / 2, cy = (p1.y + p2.y) / 2;
    state.pinchTarget = 'background';
    for (let i = state.texts.length - 1; i >= 0; i--) {
      const bound = state.textBounds[i];
      if (bound && cx > bound.x && cx < bound.x + bound.width &&
          cy > bound.y && cy < bound.y + bound.height) {
        state.pinchTarget = 'text';
        state.selected = state.texts[i];
        state.selectedType = 'text';
        break;
      }
    }
    if (state.pinchTarget === 'background') {
      for (let i = state.images.length - 1; i >= 0; i--) {
        if (isPointInObject({x: cx, y: cy}, state.images[i], false)) {
          state.pinchTarget = 'selectedImg';
          state.selectedImgIndex = i;
          state.selectedType = 'image';
          break;
        }
      }
    }
    state.pinchStartDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    if (state.pinchTarget === 'text') {
      state.textPinchStartScale = state.selected.scale;
      state.textPinchStartDist = state.pinchStartDist;
    } else if (state.pinchTarget === 'selectedImg') {
      state.selectedImgPinchStartScale = state.images[state.selectedImgIndex].scale;
      state.selectedImgPinchStartDist = state.pinchStartDist;
    } else {
      state.pinchStartScale = 1;
      state.pinchCenter = {x: cx, y: cy};
      state.imgOffsetFromCenter = { x: 0, y: 0 };
    }
    updateSelectionDisplay();
    scheduleRedraw();
  }
}, {passive: false});
elements.canvas.addEventListener('touchmove', (e) => {
  if (e.touches.length !== 2) return;
  e.preventDefault();
  const p1 = getTouchCanvasPos(e.touches[0]);
  const p2 = getTouchCanvasPos(e.touches[1]);
  const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
  if (state.pinchTarget === 'text' && state.selectedType === 'text' && state.selected) {
    const factor = dist / state.textPinchStartDist;
    state.selected.scale = clamp(state.textPinchStartScale * factor, 0.1, 8);
    updateTextBounds();
    scheduleRedraw();
  } else if (state.pinchTarget === 'selectedImg' && state.selectedType === 'image' && state.selectedImgIndex >= 0) {
    const factor = dist / state.selectedImgPinchStartDist;
    state.images[state.selectedImgIndex].scale = clamp(state.selectedImgPinchStartScale * factor, 0.1, 8);
    scheduleRedraw();
  }
}, {passive: false});
/* ========= Event Listeners ========= */
const initEventListeners = () => {
  // Close
  elements.closeText.addEventListener('click', () => {
    state.selected = null;
    state.selectedType = null;
    state.showHandles = false;
    state.transformMode = null;
    updateSelectionDisplay();
    scheduleRedraw();
  });
  elements.closeImage.addEventListener('click', () => {
    state.selectedImgIndex = -1;
    state.selectedType = null;
    state.showHandles = false;
    state.transformMode = null;
    updateSelectionDisplay();
    scheduleRedraw();
  });
  // Move buttons
  elements.moveTextBtn.addEventListener('click', () => {
    if (state.selectedType === 'text' && state.selected) {
      state.showHandles = !state.showHandles;
      updateSelectionDisplay();
      scheduleRedraw();
    }
  });
  elements.moveImgBtn.addEventListener('click', () => {
    if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.showHandles = !state.showHandles;
      updateSelectionDisplay();
      scheduleRedraw();
    }
  });
  // Duplicate button
  elements.duplicateBtn.addEventListener('click', () => {
    if (!state.selected || state.selectedType !== 'text') return;
    const duplicate = { ...state.selected };
    duplicate.x += 50;
    duplicate.y += 20;
    state.texts.push(duplicate);
    updateTextBounds();
    updateItemSelectOptions();
    scheduleRedraw();
  });
  // Item select
  elements.itemSelect.addEventListener('change', (e) => {
    const value = e.target.value;
    state.showHandles = false;
    state.transformMode = null;
    if (!value) {
      state.selected = null;
      state.selectedImgIndex = -1;
      state.selectedType = null;
      updateSelectionDisplay();
      scheduleRedraw();
      return;
    }
    const [type, index] = value.split('-');
    if (type === 'text') {
      state.selected = state.texts[parseInt(index)];
      state.selectedType = 'text';
      state.selectedImgIndex = -1;
      state.showHandles = true;
    } else if (type === 'image') {
      state.selectedImgIndex = parseInt(index);
      state.selectedType = 'image';
      state.selected = null;
    }
    updateSelectionDisplay();
    scheduleRedraw();
  });
  // Selected controls
  elements.selectedColor.addEventListener('input', () => {
    if (state.selected && state.selectedType === 'text') {
      state.selected.color = elements.selectedColor.value;
      scheduleRedraw();
    }
  });
  elements.selectedFont.addEventListener('change', () => {
    if (state.selected && state.selectedType === 'text') {
      state.selected.font = elements.selectedFont.value;
      scheduleRedraw();
    }
  });
  elements.textShadow.addEventListener('change', () => {
    if (state.selected && state.selectedType === 'text') {
      state.selected.shadow = elements.textShadow.checked;
      scheduleRedraw();
    }
  });
  // Text zoom
  elements.textZoomIn.addEventListener('click', () => {
    if (state.selected && state.selectedType === 'text') {
      state.selected.scale = clamp(state.selected.scale * 1.1, 0.1, 8);
      if (state.showHandles) updateTextBounds();
      scheduleRedraw();
    }
  });
  elements.textZoomOut.addEventListener('click', () => {
    if (state.selected && state.selectedType === 'text') {
      state.selected.scale = clamp(state.selected.scale / 1.1, 0.1, 8);
      if (state.showHandles) updateTextBounds();
      scheduleRedraw();
    }
  });
  // Image zoom
  elements.imgZoomIn.addEventListener('click', () => {
    if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.images[state.selectedImgIndex].scale = clamp(state.images[state.selectedImgIndex].scale * 1.1, 0.1, 8);
      scheduleRedraw();
    }
  });
  elements.imgZoomOut.addEventListener('click', () => {
    if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.images[state.selectedImgIndex].scale = clamp(state.images[state.selectedImgIndex].scale / 1.1, 0.1, 8);
      scheduleRedraw();
    }
  });
  // Crop
  elements.freeCropBtn.addEventListener('click', () => {
    if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.currentCropImg = state.images[state.selectedImgIndex];
      state.cropping = true;
      elements.cropOverlay.style.display = 'block';
      elements.cropCanvas.width = elements.canvas.width;
      elements.cropCanvas.height = elements.canvas.height;
      elements.cropCtx.drawImage(elements.canvas, 0, 0);
      state.cropPoints = [];
      drawCrop();
    }
  });
  elements.cropOverlay.addEventListener('pointerdown', startCrop);
  elements.cropOverlay.addEventListener('pointermove', drawCrop);
  elements.cropOverlay.addEventListener('pointerup', endCrop);
  elements.cropOverlay.addEventListener('click', () => {
    if (!state.cropping) {
      state.cropping = false;
      elements.cropOverlay.style.display = 'none';
    }
  });
  // Text input debounce
  let inputTimeout;
  elements.textInput.addEventListener('input', () => {
    clearTimeout(inputTimeout);
    inputTimeout = setTimeout(() => {
      const val = elements.textInput.value;
      if (val.trim()) {
        if (!state.previewText) {
          state.previewText = {
            text: '',
            x: elements.canvas.width / 2,
            y: elements.canvas.height / 2,
            scale: 1.5,
            rotation: 0,
            color: state.defaultHeadlineColor,
            font: state.defaultFont,
            shadow: true
          };
        }
        state.previewText.text = val;
      } else {
        state.previewText = null;
      }
      scheduleRedraw();
    }, 150);
  });
  // Source input debounce
  let sourceTextInputTimeout;
  elements.sourceInput.addEventListener('input', () => {
    clearTimeout(sourceTextInputTimeout);
    sourceTextInputTimeout = setTimeout(() => {
      const val = elements.sourceInput.value.trim();
      state.sourceObj.text = val;
      scheduleRedraw();
    }, 150);
  });
  elements.sourceColor.addEventListener('input', () => {
    state.sourceObj.color = elements.sourceColor.value;
    scheduleRedraw();
  });
  elements.sourceFont.addEventListener('change', () => {
    state.sourceObj.font = elements.sourceFont.value;
    scheduleRedraw();
  });
  elements.sourceShadow.addEventListener('change', () => {
    state.sourceObj.shadow = elements.sourceShadow.checked;
    scheduleRedraw();
  });
  elements.sourceZoomIn.addEventListener('click', () => {
    state.sourceObj.scale = clamp(state.sourceObj.scale * 1.1, 0.1, 3);
    scheduleRedraw();
  });
  elements.sourceZoomOut.addEventListener('click', () => {
    state.sourceObj.scale = clamp(state.sourceObj.scale / 1.1, 0.1, 3);
    scheduleRedraw();
  });
  // Zoom buttons
  elements.zoomInBtn.addEventListener('click', () => {
    if (state.selectedType === 'text' && state.selected) {
      state.selected.scale = clamp(state.selected.scale * 1.1, 0.1, 8);
      updateTextBounds();
    } else if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.images[state.selectedImgIndex].scale = clamp(state.images[state.selectedImgIndex].scale * 1.1, 0.1, 8);
    }
    scheduleRedraw();
  });
  elements.zoomOutBtn.addEventListener('click', () => {
    if (state.selectedType === 'text' && state.selected) {
      state.selected.scale = clamp(state.selected.scale / 1.1, 0.1, 8);
      updateTextBounds();
    } else if (state.selectedType === 'image' && state.selectedImgIndex >= 0) {
      state.images[state.selectedImgIndex].scale = clamp(state.images[state.selectedImgIndex].scale / 1.1, 0.1, 8);
    }
    scheduleRedraw();
  });
  // Edit/Delete
  elements.editBtn.addEventListener('click', () => {
    if (!state.selected || state.selectedType !== 'text') return;
    const t = prompt('Edit text:', state.selected.text);
    if (t !== null) {
      state.selected.text = t;
      updateTextBounds();
      scheduleRedraw();
    }
  });
  elements.delBtn.addEventListener('click', () => {
    if (!state.selected || state.selectedType !== 'text') return;
    if (confirm('Are you sure you want to delete this text?')) {
      state.texts = state.texts.filter(tb => tb !== state.selected);
      state.selected = null;
      state.selectedType = null;
      state.showHandles = false;
      updateTextBounds();
      scheduleRedraw();
    }
  });
  // Download
  elements.downloadBtn.addEventListener('click', () => {
    const a = document.createElement('a');
    a.download = 'poster.png';
    a.href = elements.canvas.toDataURL('image/png', 0.9);
    a.click();
  });
  // Uploader
  elements.uploader.addEventListener('change', (e) => {
    const files = Array.from(e.target.files || []);
    files.forEach(file => {
      if (!file.type.startsWith('image/')) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          const quality = state.isMobile ? 0.6 : 0.8;
          const resizedSrc = resizeImage(img, elements.canvas.width, elements.canvas.height, quality);
          const resizedImg = new Image();
          resizedImg.onload = () => {
            const scale = Math.min(elements.canvas.width / resizedImg.width * 0.8, elements.canvas.height / resizedImg.height * 0.8);
            let imgToPush = resizedImg;
            const pushImage = (finalImg) => {
              state.images.push({
                img: finalImg,
                x: Math.random() * elements.canvas.width,
                y: Math.random() * elements.canvas.height,
                scale: scale,
                rotation: 0,
                croppedData: null
              });
              state.selectedImgIndex = state.images.length - 1;
              state.selectedType = 'image';
              state.showHandles = false;
              updateSelectionDisplay();
              scheduleRedraw();
            };
            if ('createImageBitmap' in window) {
              createImageBitmap(resizedImg).then(bitmap => {
                imgToPush = bitmap;
                pushImage(imgToPush);
              }).catch(() => {
                pushImage(resizedImg);
              });
            } else {
              pushImage(resizedImg);
            }
          };
          resizedImg.src = resizedSrc;
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });
    elements.uploader.value = '';
  });
  // Add Text
  elements.addTextBtn.addEventListener('click', () => {
    const val = elements.textInput.value.trim();
    if (!val) return;
    const newText = {
      text: val,
      x: elements.canvas.width / 2,
      y: elements.canvas.height / 2,
      scale: 1.5,
      rotation: 0,
      color: state.defaultHeadlineColor,
      font: state.defaultFont,
      shadow: true
    };
    state.texts.push(newText);
    state.previewText = null;
    elements.textInput.value = '';
    state.selected = newText;
    state.selectedType = 'text';
    state.showHandles = true;
    updateSelectionDisplay();
    updateTextBounds();
    scheduleRedraw();
  });
};
/* ========= Init ========= */
document.addEventListener('DOMContentLoaded', () => {
  loadFonts();
  initEventListeners();
  frame.onload = () => {
    elements.canvas.width = frame.width;
    elements.canvas.height = frame.height;
    state.usableWidth = elements.canvas.width - state.framePadding * 2;
    state.currentDate = getBengaliDate();
    if ('createImageBitmap' in window) {
      createImageBitmap(frame).then(bm => {
        frameBitmap = bm;
        scheduleRedraw();
      }).catch(() => {
        scheduleRedraw();
      });
    } else {
      scheduleRedraw();
    }
  };
});
</script>
</body>
</html>
