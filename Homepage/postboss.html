<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="UTF-8" />
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>BeautifulDinajpur Poster Builder</title>
<style>
  :root{
    --bg:#111418; --panel:#1b2030; --panel-2:#23293a; --text:#e9eef5;
    --accent:#6ea8fe; --muted:#a9b2c7;
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:0; background:var(--bg); color:var(--text);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    display:flex; flex-direction:column; align-items:center;
  }
  h2{font-weight:700; letter-spacing:.3px; margin:14px 12px 6px}
  #app{
    width:min(100vw,640px);
    display:flex; flex-direction:column; gap:8px; padding:8px;
  }
  /* Canvas area */
  #canvas-wrap{
    position:relative; border-radius:16px; overflow:hidden;
    background:#000; box-shadow:0 8px 24px rgba(0,0,0,.35);
    touch-action:none;
    will-change: transform; /* For smoother mobile rendering */
  }
  canvas{ width:100%; height:auto; display:block; image-rendering: -webkit-optimize-contrast; }
  /* Floating text action icons */
  #textIcons{
    position:absolute; display:none; gap:4px; z-index:5;
    transform:translate(-50%,-100%);
  }
  #textIcons button{
    border:none; outline:none; border-radius:8px;
    padding:6px 8px; font-size:14px; line-height:1;
    background:var(--panel-2); color:var(--text);
    box-shadow:0 4px 14px rgba(0,0,0,.35);
  }
  #textIcons button:active{ transform:scale(.98); }
  #textIcons input[type="color"] {
    width:20px; height:20px; padding:0; border:none; outline:none;
    border-radius:4px; cursor:pointer; background:transparent;
  }
  #textIcons select {
    font-size:12px; padding:2px 4px; background:var(--panel-2); color:var(--text);
    border:none; outline:none; border-radius:4px; min-width:60px;
  }
  #textIcons input[type="checkbox"] {
    width:16px; height:16px; accent-color: var(--accent);
  }
  /* Floating image action icons */
  #imageIcons{
    position:absolute; display:none; gap:4px; z-index:5;
    left:50%; top:20px; transform:translateX(-50%);
  }
  #imageIcons button{
    border:none; outline:none; border-radius:8px;
    padding:6px 8px; font-size:14px; line-height:1;
    background:var(--panel-2); color:var(--text);
    box-shadow:0 4px 14px rgba(0,0,0,.35);
  }
  #imageIcons button:active{ transform:scale(.98); }
  /* Crop mode overlay */
  #cropOverlay{
    position:absolute; top:0; left:0; width:100%; height:100%; 
    background:rgba(0,0,0,0.5); display:none; z-index:10;
    cursor:crosshair;
  }
  #cropCanvas{ position:absolute; top:0; left:0; width:100%; height:100%; }
  /* Top controls - Compact version */
  #controls{
    background:var(--panel); border-radius:12px; padding:6px;
    display:flex; flex-direction:column; gap:6px;
  }
  #controls input[type="text"]{ 
    width:100%; 
  }
  #controls input[type="file"],
  #controls input[type="text"],
  #controls select,
  #controls button{
    border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:14px; background:var(--panel-2); color:var(--text);
    min-height:44px; /* Touch-friendly */
    -webkit-tap-highlight-color: transparent;
  }
  #controls button.primary{ background:var(--accent); color:#0b1020; font-weight:700; }
  #sourceGroup {
    display:flex; flex-wrap:wrap; gap:6px; align-items:center;
  }
  #sourceGroup input[type="color"] { flex:1; padding:4px; min-width:60px; }
  #sourceGroup select { flex:2; min-width:100px; }
  #sourceGroup .small-btn {
    padding:4px 6px; font-size:12px; min-width:30px;
  }
  #sourceGroup label {
    display:flex; align-items:center; gap:4px; font-size:12px; white-space:nowrap;
  }
  .row {
    display: flex; gap: 6px; align-items: center; flex-wrap:wrap;
  }
  .row input[type="file"], .row select {
    flex: 1; min-width:120px;
  }
  .headline-row {
    display: flex; gap: 6px; align-items: center; flex-wrap:wrap;
  }
  .headline-row input[type="text"] {
    flex: 1; min-width: 120px;
  }
  /* Bottom controls - Slightly compact */
  #bottom-controls{
    display:flex; gap:8px; align-items:center; justify-content:space-between;
    background:var(--panel); border-radius:12px; padding:6px;
    flex-wrap: wrap;
  }
  #bottom-controls .group{ display:flex; gap:6px; }
  .btn{
    border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:16px; background:var(--panel-2); color:var(--text);
    min-width:44px; min-height:44px; text-align:center; /* Touch-friendly */
    -webkit-tap-highlight-color: transparent;
  }
  .btn.primary{ background:var(--accent); color:#0b1020; font-weight:700; }
  #zoomPercent{ color:var(--muted); font-weight:600; font-size:14px; }
  /* Selection dropdown */
  #itemSelect {
    background:var(--panel-2); color:var(--text); border:none; outline:none; border-radius:8px;
    padding:8px 10px; font-size:14px; min-width:120px; min-height:44px;
  }
  /* Selected badge (optional hint) */
  #selectedBadge{
    position:absolute; left:50%; top:8px; transform:translateX(-50%);
    background:rgba(110,168,254,.18); color:#cfe0ff;
    padding:12px 12px; border-radius:999px; font-size:13px;
    pointer-events:none; display:none; z-index:4;
  }
  /* Source input */
  #sourceInput {
    margin-top: 0;
  }
  /* Media Queries for Responsiveness */
  @media (max-width: 480px) {
    #app { padding: 4px; gap: 4px; }
    #controls { padding: 4px; gap: 4px; }
    #bottom-controls { padding: 4px; gap: 4px; }
    #sourceGroup { flex-direction: column; align-items: stretch; }
    .row, .headline-row { flex-direction: column; align-items: stretch; }
    .btn, #controls input[type="file"], #controls input[type="text"], #controls select, #itemSelect { font-size: 16px; padding: 12px; min-height: 48px; }
    #sourceGroup .small-btn { min-width: 40px; min-height: 40px; }
    #textIcons, #imageIcons { gap: 2px; }
    #textIcons button, #imageIcons button { padding: 4px 6px; font-size: 12px; }
  }
  @media (max-width: 320px) {
    #zoomPercent { font-size: 12px; }
    .btn { min-width: 36px; min-height: 36px; font-size: 14px; padding: 6px; }
  }
</style>
</head>
<body>
  <h2>BeautifulDinajpur Poster Builder</h2>

  <div id="app">
    <!-- Canvas Area -->
    <div id="canvas-wrap">
      <canvas id="poster"></canvas>
      <div id="selectedBadge">Selected</div>
      <div id="textIcons">
        <button id="moveTextBtn" title="Free Transform">‚ÜîÔ∏è</button>
        <button id="editBtn" title="Edit text">‚úèÔ∏è</button>
        <input type="color" id="selectedColor" title="Change color" />
        <select id="selectedFont" title="Change font"></select>
        <input type="checkbox" id="textShadow" title="Toggle shadow" checked />
        <button id="textZoomOut" title="Text Zoom Out">-</button>
        <button id="textZoomIn" title="Text Zoom In">+</button>
        <button id="closeText" title="Close Selection">‚úï</button>
        <button id="delBtn" title="Delete text">üóëÔ∏è</button>
      </div>
      <div id="imageIcons">
        <button id="moveImgBtn" title="Free Transform">‚ÜîÔ∏è</button>
        <button id="imgZoomOut" title="Image Zoom Out">-</button>
        <button id="imgZoomIn" title="Image Zoom In">+</button>
        <button id="freeCropBtn" title="Freehand Crop">‚úÇÔ∏è</button>
        <button id="closeImage" title="Close Selection">‚úï</button>
      </div>
      <div id="cropOverlay">
        <canvas id="cropCanvas"></canvas>
      </div>
    </div>

    <!-- Controls - Compact -->
    <div id="controls">
      <div class="row">
        <input type="file" id="uploader" accept="image/*" multiple />
        <select id="itemSelect">
          <option value="">‡¶ï‡ßã‡¶® ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®</option>
        </select>
      </div>
      <div class="headline-row">
        <input type="text" id="textInput" placeholder="‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (headline / caption)" />
        <button id="addText" class="primary">+ Add Text</button>
      </div>
      <input type="text" id="sourceInput" placeholder="‡¶§‡¶•‡ßç‡¶Ø‡¶∏‡ßÇ‡¶§‡ßç‡¶∞ ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶® (‡¶â‡ßé‡¶∏)" />
      <div id="sourceGroup">
        <input type="color" id="sourceColor" value="#ffffff" />
        <select id="sourceFont">
          <option value="sans-serif">Loading fonts...</option>
        </select>
        <label><input type="checkbox" id="sourceShadow" checked /> ‡¶∂‡ßç‡¶Ø‡¶æ‡¶°‡ßã</label>
        <button id="sourceZoomOut" class="small-btn" title="Source Zoom Out">‚Äì</button>
        <button id="sourceZoomIn" class="small-btn" title="Source Zoom In">+</button>
      </div>
    </div>

    <!-- Bottom bar -->
    <div id="bottom-controls">
      <div class="group">
        <button id="zoomOut" class="btn">‚Äì</button>
        <button id="zoomIn" class="btn">+</button>
      </div>
      <div id="zoomPercent">Image Zoom: 100%</div>
      <button id="download" class="btn primary">Download</button>
    </div>
  </div>

<script>
/* ========= State ========= */
const canvas = document.getElementById('poster');
const ctx = canvas.getContext('2d', { willReadFrequently: true, alpha: false }); // alpha: false for perf
const cropCanvas = document.getElementById('cropCanvas');
const cropCtx = cropCanvas.getContext('2d');

const uploader   = document.getElementById('uploader');
const textInput  = document.getElementById('textInput');
const sourceInput = document.getElementById('sourceInput');
const fontSelect = document.getElementById('fontSelect');
const addTextBtn = document.getElementById('addText');
const sourceColor = document.getElementById('sourceColor');
const sourceFont = document.getElementById('sourceFont');
const sourceShadow = document.getElementById('sourceShadow');
const sourceZoomIn = document.getElementById('sourceZoomIn');
const sourceZoomOut = document.getElementById('sourceZoomOut');

const zoomInBtn  = document.getElementById('zoomIn');
const zoomOutBtn = document.getElementById('zoomOut');
const zoomLabel  = document.getElementById('zoomPercent');
const downloadBtn= document.getElementById('download');
const itemSelect = document.getElementById('itemSelect');

const textIcons  = document.getElementById('textIcons');
const imageIcons = document.getElementById('imageIcons');
const cropOverlay = document.getElementById('cropOverlay');
const editBtn    = document.getElementById('editBtn');
const delBtn     = document.getElementById('delBtn');
const closeText  = document.getElementById('closeText');
const closeImage = document.getElementById('closeImage');
const selectedBadge = document.getElementById('selectedBadge');
const selectedColor = document.getElementById('selectedColor');
const selectedFont  = document.getElementById('selectedFont');
const textShadow   = document.getElementById('textShadow');
const textZoomIn = document.getElementById('textZoomIn');
const textZoomOut = document.getElementById('textZoomOut');
const imgZoomIn = document.getElementById('imgZoomIn');
const imgZoomOut = document.getElementById('imgZoomOut');
const freeCropBtn = document.getElementById('freeCropBtn');
const moveTextBtn = document.getElementById('moveTextBtn');
const moveImgBtn = document.getElementById('moveImgBtn');

/* Frame overlay (Facebook style) */
const frame = new Image();
frame.src = 'post.png'; // keep your frame file here
frame.crossOrigin = 'anonymous'; // For canvas tainting if needed
let frameBitmap = null;

/* Images state - now multiple */
let images = []; // {img, x, y, scale, rotation, croppedData?}
let selectedImg = null; // selected image index or null

/* Text blocks */
let texts = [];   // { text, x, y, scale, rotation, color, font, shadow: true }
let previewText = null; // For live preview
let selected = null;
let selectedType = null; // 'text' or 'image'

/* Date and source info */
let currentDate = '';
let sourceObj = { text: '', color: '#ffffff', font: 'sans-serif', shadow: true, scale: 1 };
let defaultFont = 'sans-serif'; // Will be set after fonts load
let defaultHeadlineColor = '#ffffff'; // Default color for headlines

/* Interaction state */
let selectedImgIndex = -1;
let showHandles = false;
let transformMode = null; // 'move', 'scale', 'rotate'
let currentObj = null;
let isCurrentText = false;
let dragStartX = 0, dragStartY = 0;
let startObjX = 0, startObjY = 0;
let startScale = 1;
let startRadial = 0;
let prevAngle = 0;

/* Pinch state */
let pinchTarget = ''; // 'image' | 'text' | 'selectedImg'
let pinchStartDist = 0, pinchStartScale = 1;
let pinchCenter = {x:0,y:0};
let imgOffsetFromCenter = {x:0,y:0};

let textPinchStartDist = 0, textPinchStartScale = 1;
let selectedImgPinchStartDist = 0, selectedImgPinchStartScale = 1;

/* Crop state */
let cropping = false;
let cropPoints = [];
let currentCropImg = null;

/* Optimization state */
let needsRedraw = false;
let redrawTimeout = null;
let textBounds = []; // Cached bounds for texts: {index, x, y, width, height}
let lastDrawTime = 0;
const framePadding = 40;           
let usableWidth  = 0; // Set after canvas size
const baseFontPx   = 34;           
const baseLineH    = 50;           
let MIN_REDRAW_INTERVAL = 16; // ~60fps
const handleRadius = 8;
const rotOffset = 40;
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
MIN_REDRAW_INTERVAL = isMobile ? 33 : 16; // 30fps on mobile

/* ========= Helpers ========= */
function clamp(v, min, max){ return Math.min(Math.max(v, min), max); }

function deviceToCanvas(px, py){
  const r = canvas.getBoundingClientRect();
  return {
    x: (px - r.left) * (canvas.width / r.width),
    y: (py - r.top)  * (canvas.height / r.height)
  };
}
function getTouchCanvasPos(t){ return deviceToCanvas(t.clientX, t.clientY); }

/* ========= Get Unscaled Dims ========= */
function getUnscaledDims(obj, isText) {
  if (isText) {
    const dims = getWrappedTextDimensions(obj);
    const s = obj.scale;
    return { width: dims.width / s, height: dims.height / s };
  } else {
    return { width: obj.img.width, height: obj.img.height };
  }
}

/* ========= Point in Object (with rotation and scale) for images ========= */
function isPointInObject(p, obj, isText) {
  if (isText) {
    // For text, use cached bounds for faster hit test
    const index = texts.indexOf(obj);
    if (index === -1) return false;
    const bound = textBounds[index];
    if (!bound) return false;
    // For rotated text, the bounds are axis-aligned, so approximate hit test
    // To be more accurate, we could transform the point, but for simplicity use AABB
    return (p.x > bound.x && p.x < bound.x + bound.width &&
            p.y > bound.y && p.y < bound.y + bound.height);
  } else {
    // For images, full transform
    const s = obj.scale;
    const th = obj.rotation;
    const cos = Math.cos(th);
    const sin = Math.sin(th);
    let dx = p.x - obj.x;
    let dy = p.y - obj.y;
    let itx = cos * dx + sin * dy;
    let ity = -sin * dx + cos * dy;
    let local_x = itx / s;
    let local_y = ity / s;
    let unscaled = getUnscaledDims(obj, false);
    let halfUnW = unscaled.width / 2;
    let halfUnH = unscaled.height / 2;
    return Math.abs(local_x) <= halfUnW && Math.abs(local_y) <= halfUnH;
  }
}

/* ========= Image Resize for Mobile ========= */
function resizeImage(img, maxWidth, maxHeight, quality = 0.8) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  let {width, height} = img;
  if (width > maxWidth || height > maxHeight) {
    const ratio = Math.min(maxWidth / width, maxHeight / height);
    width *= ratio;
    height *= ratio;
  }
  canvas.width = width;
  canvas.height = height;
  ctx.drawImage(img, 0, 0, width, height);
  return canvas.toDataURL('image/jpeg', quality);
}

/* ========= Throttled Redraw ========= */
function scheduleRedraw() {
  const now = performance.now();
  if (now - lastDrawTime < MIN_REDRAW_INTERVAL) return; // Skip if too soon
  needsRedraw = true;
  if (redrawTimeout) return;
  redrawTimeout = requestAnimationFrame(() => {
    if (needsRedraw) {
      draw();
      needsRedraw = false;
      lastDrawTime = performance.now();
    }
    redrawTimeout = null;
  });
}

/* ========= Update Selected Controls ========= */
function updateSelectedControls() {
  if (selected && selectedType === 'text') {
    selectedColor.value = selected.color;
    selectedFont.value = selected.font;
    textShadow.checked = selected.shadow !== false;
  }
}

/* ========= Update Dynamic Selection ========= */
function updateSelectionDisplay() {
  let badgeText = 'Selected';
  if (showHandles) badgeText = 'Free Transform';
  else if (selectedType === 'text' && selected) badgeText = 'Text Selected';
  else if (selectedType === 'image') badgeText = 'Image Selected';
  selectedBadge.textContent = badgeText;
  selectedBadge.style.display = selectedType ? 'block' : 'none';
  if (selectedType === 'text' && selected) {
    textIcons.style.display = 'flex';
    imageIcons.style.display = 'none';
    const rect = canvas.getBoundingClientRect();
    const left = selected.x * rect.width / canvas.width;
    const top  = selected.y * rect.height / canvas.height;
    textIcons.style.left = left + 'px';
    textIcons.style.top  = top + 'px';
    updateSelectedControls();
  } else if (selectedType === 'image') {
    imageIcons.style.display = 'flex';
    textIcons.style.display = 'none';
    if (selectedImgIndex !== -1) {
      const imgObj = images[selectedImgIndex];
      const rect = canvas.getBoundingClientRect();
      const left = imgObj.x * rect.width / canvas.width;
      const top  = imgObj.y * rect.height / canvas.height - 20;
      imageIcons.style.left = left + 'px';
      imageIcons.style.top  = top + 'px';
    } else {
      imageIcons.style.left = '50%';
      imageIcons.style.top = '20px';
    }
  } else {
    textIcons.style.display = 'none';
    imageIcons.style.display = 'none';
  }
  updateItemSelectOptions();
}

/* ========= Update Item Select Dropdown ========= */
function updateItemSelectOptions() {
  itemSelect.innerHTML = '<option value="">‡¶ï‡ßã‡¶® ‡¶Ü‡¶á‡¶ü‡ßá‡¶Æ ‡¶∏‡¶ø‡¶≤‡ßá‡¶ï‡ßç‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®</option>';
  texts.forEach((t, i) => {
    const opt = document.createElement('option');
    opt.value = `text-${i}`;
    opt.textContent = `‡¶ü‡ßá‡¶ï‡ßç‡¶∏‡¶ü: ${t.text.substring(0, 20)}${t.text.length > 20 ? '...' : ''}`;
    itemSelect.appendChild(opt);
  });
  images.forEach((img, i) => {
    const opt = document.createElement('option');
    opt.value = `image-${i}`;
    opt.textContent = `‡¶á‡¶Æ‡ßá‡¶ú ${i + 1}`;
    itemSelect.appendChild(opt);
  });
}

/* ========= Update Preview ========= */
function updatePreview() {
  if (previewText) {
    previewText.color = defaultHeadlineColor;
    previewText.font = defaultFont;
    scheduleRedraw();
  }
}

/* ========= Load Fonts Dynamically with Cache ========= */
async function loadFonts() {
  const cacheKey = 'fontList';
  const cached = localStorage.getItem(cacheKey);
  const now = Date.now();
  const cacheExpiry = 24 * 60 * 60 * 1000; // 24 hours

  let data;
  if (cached) {
    const { timestamp, files } = JSON.parse(cached);
    if (now - timestamp < cacheExpiry) {
      data = { files };
      console.log('Loaded fonts from cache');
    }
  }

  if (!data) {
    try {
      const response = await fetch('https://raw.githubusercontent.com/prodhan2/beautifulDinajpurFrames/main/font/file_list.json');
      data = await response.json();
      localStorage.setItem(cacheKey, JSON.stringify({ timestamp: now, files: data.files }));
      console.log('Fetched and cached fonts');
    } catch (error) {
      console.error('Failed to load fonts:', error);
      // Fallback
      data = { files: [] };
    }
  }

  const files = data.files || [];

  if (files.length === 0) {
    console.warn('No fonts found');
    return;
  }

  // Create dynamic stylesheet for @font-face
  const style = document.createElement('style');
  style.id = 'dynamic-fonts';
  let css = '';
  files.forEach(filename => {
    const fontFamily = filename.replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'unknown';
    const url = `https://raw.githubusercontent.com/prodhan2/beautifulDinajpurFrames/main/font/${filename}`;
    css += `
      @font-face {
        font-family: '${fontFamily}';
        src: url('${url}') format('truetype');
        font-weight: normal;
        font-style: normal;
        font-display: swap; /* For faster loading */
      }
    `;
  });
  style.textContent = css;
  document.head.appendChild(style);

  // Populate select dropdowns (only for source and selected)
  const options = ['<option value="sans-serif">Sans-serif</option>'];
  files.forEach(filename => {
    const fontFamily = filename.replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'unknown';
    const displayName = filename.replace(/\.TTF$/i, '');
    options.push(`<option value="${fontFamily}">${displayName}</option>`);
  });
  const optHtml = options.join('');
  selectedFont.innerHTML = optHtml;
  sourceFont.innerHTML = optHtml;

  // Set default font to first one
  if (files.length > 0) {
    defaultFont = files[0].replace(/\.TTF$/i, '').replace(/[^a-zA-Z0-9]/g, '').toLowerCase() || 'sans-serif';
    selectedFont.value = defaultFont;
    sourceFont.value = defaultFont;
    sourceObj.font = defaultFont;
  }

  console.log('Fonts loaded:', files.length);
}

/* ========= Bengali Date Functions ========= */
function getBengaliDate() {
  const now = new Date(); // Use current date
  const day = now.getDate();
  const month = now.getMonth();
  const year = now.getFullYear();
  
  // Bengali month names
  const bengaliMonths = [
    '‡¶ú‡¶æ‡¶®‡ßÅ‡¶Ø‡¶º‡¶æ‡¶∞‡¶ø', '‡¶´‡ßá‡¶¨‡ßç‡¶∞‡ßÅ‡¶Ø‡¶º‡¶æ‡¶∞‡¶ø', '‡¶Æ‡¶æ‡¶∞‡ßç‡¶ö', '‡¶è‡¶™‡ßç‡¶∞‡¶ø‡¶≤', '‡¶Æ‡ßá', '‡¶ú‡ßÅ‡¶®',
    '‡¶ú‡ßÅ‡¶≤‡¶æ‡¶á', '‡¶Ü‡¶ó‡¶∏‡ßç‡¶ü', '‡¶∏‡ßá‡¶™‡ßç‡¶ü‡ßá‡¶Æ‡ßç‡¶¨‡¶∞', '‡¶Ö‡¶ï‡ßç‡¶ü‡ßã‡¶¨‡¶∞', '‡¶®‡¶≠‡ßá‡¶Æ‡ßç‡¶¨‡¶∞', '‡¶°‡¶ø‡¶∏‡ßá‡¶Æ‡ßç‡¶¨‡¶∞'
  ];
  
  // Convert numbers to Bengali digits
  function toBengaliDigits(number) {
    const bengaliDigits = ['‡ß¶', '‡ßß', '‡ß®', '‡ß©', '‡ß™', '‡ß´', '‡ß¨', '‡ß≠', '‡ßÆ', '‡ßØ'];
    return number.toString().replace(/\d/g, digit => bengaliDigits[parseInt(digit)]);
  }
  
  return `${toBengaliDigits(day)} ${bengaliMonths[month]} ${toBengaliDigits(year)}`;
}

/* ========= Init ========= */
document.addEventListener('DOMContentLoaded', () => {
  loadFonts(); // Load fonts first

  // Close buttons
  closeText.addEventListener('click', () => {
    selected = null;
    selectedType = null;
    showHandles = false;
    transformMode = null;
    updateSelectionDisplay();
    scheduleRedraw();
  });
  closeImage.addEventListener('click', () => {
    selectedImgIndex = -1;
    selectedType = null;
    showHandles = false;
    transformMode = null;
    updateSelectionDisplay();
    scheduleRedraw();
  });

  // Move buttons for free transform
  moveTextBtn.addEventListener('click', () => {
    if (selectedType === 'text' && selected) {
      showHandles = !showHandles;
      updateSelectionDisplay();
      scheduleRedraw();
    }
  });
  moveImgBtn.addEventListener('click', () => {
    if (selectedType === 'image' && selectedImgIndex >= 0) {
      showHandles = !showHandles;
      updateSelectionDisplay();
      scheduleRedraw();
    }
  });

  // Item select dropdown
  itemSelect.addEventListener('change', (e) => {
    const value = e.target.value;
    showHandles = false;
    transformMode = null;
    if (!value) {
      selected = null;
      selectedImgIndex = -1;
      selectedType = null;
      updateSelectionDisplay();
      scheduleRedraw();
      return;
    }
    const [type, index] = value.split('-');
    if (type === 'text') {
      selected = texts[parseInt(index)];
      selectedType = 'text';
      selectedImgIndex = -1;
    } else if (type === 'image') {
      selectedImgIndex = parseInt(index);
      selectedType = 'image';
      selected = null;
    }
    updateSelectionDisplay();
    scheduleRedraw();
  });

  // Listeners for selected controls
  selectedColor.addEventListener('input', () => {
    if (selected && selectedType === 'text') {
      selected.color = selectedColor.value;
      scheduleRedraw();
    }
  });
  selectedFont.addEventListener('change', () => {
    if (selected && selectedType === 'text') {
      selected.font = selectedFont.value;
      scheduleRedraw();
    }
  });
  textShadow.addEventListener('change', () => {
    if (selected && selectedType === 'text') {
      selected.shadow = textShadow.checked;
      scheduleRedraw();
    }
  });

  // Text zoom buttons for selected
  textZoomIn.addEventListener('click', () => {
    if (selected && selectedType === 'text') {
      selected.scale = clamp(selected.scale * 1.1, 0.1, 8);
      if (showHandles) updateTextBounds();
      scheduleRedraw();
    }
  });
  textZoomOut.addEventListener('click', () => {
    if (selected && selectedType === 'text') {
      selected.scale = clamp(selected.scale / 1.1, 0.1, 8);
      if (showHandles) updateTextBounds();
      scheduleRedraw();
    }
  });

  // Image zoom buttons
  imgZoomIn.addEventListener('click', () => {
    if (selectedType === 'image' && selectedImgIndex >= 0) {
      images[selectedImgIndex].scale = clamp(images[selectedImgIndex].scale * 1.1, 0.1, 8);
      scheduleRedraw();
    }
  });
  imgZoomOut.addEventListener('click', () => {
    if (selectedType === 'image' && selectedImgIndex >= 0) {
      images[selectedImgIndex].scale = clamp(images[selectedImgIndex].scale / 1.1, 0.1, 8);
      scheduleRedraw();
    }
  });

  // Freehand crop button
  freeCropBtn.addEventListener('click', () => {
    if (selectedType === 'image' && selectedImgIndex >= 0) {
      currentCropImg = images[selectedImgIndex];
      cropping = true;
      cropOverlay.style.display = 'block';
      cropCanvas.width = canvas.width;
      cropCanvas.height = canvas.height;
      cropCtx.drawImage(canvas, 0, 0);
      cropPoints = [];
      // Draw initial crop image
      drawCropMode();
    }
  });

  // Crop overlay events
  cropOverlay.addEventListener('pointerdown', startCrop);
  cropOverlay.addEventListener('pointermove', drawCrop);
  cropOverlay.addEventListener('pointerup', endCrop);
  cropOverlay.addEventListener('click', () => {
    if (!cropping) {
      cropping = false;
      cropOverlay.style.display = 'none';
    }
  });

  // Debounced live preview on text input
  let inputTimeout;
  textInput.addEventListener('input', () => {
    clearTimeout(inputTimeout);
    inputTimeout = setTimeout(() => {
      const val = textInput.value;
      if (val.trim()) {
        if (!previewText) {
          previewText = {
            text: '',
            x: canvas.width / 2,
            y: canvas.height / 2,
            scale: 1,
            rotation: 0,
            color: defaultHeadlineColor,
            font: defaultFont,
            shadow: true
          };
        }
        previewText.text = val;
      } else {
        previewText = null;
      }
      scheduleRedraw();
    }, 150); // Slightly longer debounce for mobile
  });

  // Update preview on font change (color is now default)
  // No fontSelect for headline, so no listener

  // Source controls - automatic add to footer right
  let sourceTextInputTimeout;
  sourceInput.addEventListener('input', () => {
    clearTimeout(sourceTextInputTimeout);
    sourceTextInputTimeout = setTimeout(() => {
      const val = sourceInput.value.trim();
      sourceObj.text = val;
      scheduleRedraw();
    }, 150);
  });
  sourceColor.addEventListener('input', () => {
    sourceObj.color = sourceColor.value;
    scheduleRedraw();
  });
  sourceFont.addEventListener('change', () => {
    sourceObj.font = sourceFont.value;
    scheduleRedraw();
  });
  sourceShadow.addEventListener('change', () => {
    sourceObj.shadow = sourceShadow.checked;
    scheduleRedraw();
  });
  sourceZoomIn.addEventListener('click', () => {
    sourceObj.scale = clamp(sourceObj.scale * 1.1, 0.1, 3);
    scheduleRedraw();
  });
  sourceZoomOut.addEventListener('click', () => {
    sourceObj.scale = clamp(sourceObj.scale / 1.1, 0.1, 3);
    scheduleRedraw();
  });
});

/* ========= Crop Functions ========= */
let cropStart = {x:0, y:0};
function startCrop(e) {
  const p = deviceToCanvas(e.clientX, e.clientY);
  cropStart = p;
  cropPoints.push(p);
  drawCrop();
}

function drawCrop(e) {
  if (!cropping) return;
  const p = deviceToCanvas(e.clientX, e.clientY);
  cropCtx.clearRect(0, 0, cropCanvas.width, cropCanvas.height);
  cropCtx.drawImage(canvas, 0, 0);
  if (cropPoints.length > 0) {
    cropCtx.beginPath();
    cropCtx.moveTo(cropPoints[0].x, cropPoints[0].y);
    cropPoints.forEach(pt => cropCtx.lineTo(pt.x, pt.y));
    cropCtx.lineTo(p.x, p.y);
    cropCtx.strokeStyle = 'red';
    cropCtx.lineWidth = 2;
    cropCtx.stroke();
  }
}

function endCrop() {
  if (cropPoints.length < 3) return;
  // Simple polygon crop using offscreen canvas
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  const img = currentCropImg.img;
  tempCanvas.width = img.width;
  tempCanvas.height = img.height;
  tempCtx.drawImage(img, 0, 0);

  // Create mask from points (simplified, assume points in image coords - need transform)
  // For simplicity, assume points are relative to canvas, but adjust for image position/scale
  const imgRect = {
    x: currentCropImg.x - (img.width * currentCropImg.scale / 2),
    y: currentCropImg.y - (img.height * currentCropImg.scale / 2),
    w: img.width * currentCropImg.scale,
    h: img.height * currentCropImg.scale
  };
  // This is approximate; for real freehand, need better polygon clip
  // Use a library or simple fill for now
  cropCtx.fillStyle = 'rgba(255,0,0,0.3)';
  cropCtx.beginPath();
  cropCtx.moveTo(cropPoints[0].x, cropPoints[0].y);
  cropPoints.forEach(pt => cropCtx.lineTo(pt.x, pt.y));
  cropCtx.closePath();
  cropCtx.fill();

  // Crop the image using points (basic implementation)
  const croppedData = tempCanvas.toDataURL(); // Placeholder - actual crop needs clipPath
  currentCropImg.croppedData = croppedData;
  const newImg = new Image();
  newImg.onload = () => {
    currentCropImg.img = newImg;
  };
  newImg.src = croppedData;

  cropping = false;
  cropOverlay.style.display = 'none';
  cropPoints = [];
  scheduleRedraw();
}

/* ========= Init Canvas ========= */
frame.onload = () => {
  // Use frame native size for crisp export
  canvas.width  = frame.width;
  canvas.height = frame.height;

  // Update globals
  usableWidth = canvas.width - framePadding * 2;

  // Set current date in Bengali
  currentDate = getBengaliDate();

  // Optimize frame for mobile
  if ('createImageBitmap' in window) {
    createImageBitmap(frame).then(bm => {
      frameBitmap = bm;
      scheduleRedraw();
    }).catch(() => {
      scheduleRedraw();
    });
  } else {
    scheduleRedraw();
  }
};

/* ========= Multiple Image Upload with Resize ========= */
uploader.addEventListener('change', (e) => {
  const files = Array.from(e.target.files || []);
  files.forEach(file => {
    if (!file.type.startsWith('image/')) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      const img = new Image();
      img.onload = () => {
        // Resize for mobile performance
        const quality = isMobile ? 0.6 : 0.8;
        const resizedSrc = resizeImage(img, canvas.width, canvas.height, quality);
        const resizedImg = new Image();
        resizedImg.onload = () => {
          const scale = Math.min(canvas.width / resizedImg.width * 0.8, canvas.height / resizedImg.height * 0.8);
          let imgToPush = resizedImg;
          const pushImage = (finalImg) => {
            images.push({
              img: finalImg,
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              scale: scale,
              rotation: 0,
              croppedData: null
            });
            selectedImgIndex = images.length - 1;
            selectedType = 'image';
            showHandles = false;
            updateSelectionDisplay();
            scheduleRedraw();
          };
          if ('createImageBitmap' in window) {
            createImageBitmap(resizedImg).then(bitmap => {
              imgToPush = bitmap;
              pushImage(imgToPush);
            }).catch(() => {
              pushImage(resizedImg);
            });
          } else {
            pushImage(resizedImg);
          }
        };
        resizedImg.src = resizedSrc;
      };
      img.src = ev.target.result;
    };
    reader.readAsDataURL(file);
  });
  // Clear input for multiple uploads
  uploader.value = '';
});

/* ========= Add Text ========= */
addTextBtn.addEventListener('click', () => {
  const val = textInput.value.trim();
  if(!val) return;
  const newText = {
    text: val,
    x: canvas.width / 2,
    y: canvas.height / 2,
    scale: 1,
    rotation: 0,
    color: defaultHeadlineColor,
    font: defaultFont,
    shadow: true
  };
  texts.push(newText);
  previewText = null;
  textInput.value = '';
  selected = newText;
  selectedType = 'text';
  showHandles = false;
  updateSelectionDisplay();
  updateTextBounds(); // Update immediately for fast selection
  scheduleRedraw();
});

/* ========= Get Wrapped Text Dimensions ========= */
function getWrappedTextDimensions(tb) {
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCtx.font = `700 ${baseFontPx}px "${tb.font}"`;
  const maxLocal = usableWidth / tb.scale;
  const words = tb.text.split(' ');
  let line = '';
  let lines = [];
  let maxLocalWidth = 0;

  for (let i = 0; i < words.length; i++) {
    const test = line + words[i] + ' ';
    if (tempCtx.measureText(test).width > maxLocal && i > 0) {
      if (line.trim().length) {
        const w = tempCtx.measureText(line).width;
        maxLocalWidth = Math.max(maxLocalWidth, w);
        lines.push(line);
        line = words[i] + ' ';
      } else {
        // very long single "word" -> break by chars
        let piece = '';
        for (const ch of words[i] + ' ') {
          if (tempCtx.measureText(piece + ch).width > maxLocal) {
            const w = tempCtx.measureText(piece).width;
            maxLocalWidth = Math.max(maxLocalWidth, w);
            lines.push(piece);
            piece = ch;
          } else {
            piece += ch;
          }
        }
        const w = tempCtx.measureText(piece).width;
        maxLocalWidth = Math.max(maxLocalWidth, w);
        lines.push(piece);
        line = '';
      }
    } else {
      line = test;
    }
  }
  if (line.trim().length) {
    const w = tempCtx.measureText(line).width;
    maxLocalWidth = Math.max(maxLocalWidth, w);
    lines.push(line);
  }

  const width = maxLocalWidth * tb.scale;
  const height = lines.length * baseLineH * tb.scale;
  return { width, height };
}

/* ========= Cache Text Bounds ========= */
function updateTextBounds() {
  textBounds = [];
  texts.forEach((tb, index) => {
    const dims = getWrappedTextDimensions(tb);
    textBounds.push({
      index,
      x: tb.x - dims.width / 2,
      y: tb.y - dims.height / 2,
      width: dims.width,
      height: dims.height
    });
  });
}

/* ========= Text wrapping that respects scale (keeps inside frame) ========= */
function wrapTextScaled(ctx, text, x, y, maxWidthWorld, lineHeightWorld, scale){
  // inside a scaled context; usable local width = maxWidthWorld / scale
  const maxLocal = maxWidthWorld / scale;
  const lhLocal  = lineHeightWorld / scale;

  // Use baseline top for predictable stacking
  const oldBaseline = ctx.textBaseline;
  ctx.textBaseline = 'top';

  // Split by space; fallback to char-splitting for oversized words
  const words = text.split(' ');
  let line = '';
  let cursorY = y;

  function drawLine(str){
    ctx.fillText(str, x, cursorY);
    cursorY += lhLocal;
  }

  for(let i=0;i<words.length;i++){
    const test = line + words[i] + ' ';
    if(ctx.measureText(test).width > maxLocal && i > 0){
      // current word doesn't fit on this line
      if(line.trim().length){
        drawLine(line);
        line = words[i] + ' ';
      }else{
        // very long single "word" -> break by chars
        let piece = '';
        for(const ch of words[i] + ' '){
          if(ctx.measureText(piece + ch).width > maxLocal){
            drawLine(piece);
            piece = ch;
          }else{
            piece += ch;
          }
        }
        line = '';
      }
    }else{
      line = test;
    }
  }
  if(line.trim().length) drawLine(line);

  ctx.textBaseline = oldBaseline;
}

/* ========= Drawing ========= */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw all images
  images.forEach(imgObj => {
    ctx.save();
    ctx.translate(imgObj.x, imgObj.y);
    ctx.rotate(imgObj.rotation);
    ctx.scale(imgObj.scale, imgObj.scale);
    ctx.drawImage(imgObj.img, -imgObj.img.width / 2, -imgObj.img.height / 2);
    ctx.restore();
  });

  // Frame overlay
  ctx.drawImage(frameBitmap || frame, 0, 0, canvas.width, canvas.height);
  
  // Mobile optimized shadow blur
  const textShadowBlur = isMobile ? 2 : 4;
  const sourceShadowBlur = isMobile ? 3 : 6;
  
  // Draw date (top left) - Using default Bangla font
  if (currentDate) {
    ctx.save();
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#ffffff';
    ctx.font = `bold 35px "${defaultFont}"`;
    ctx.shadowColor = 'rgba(0,0,0,.65)';
    ctx.shadowBlur = textShadowBlur;
    ctx.fillText(currentDate, 30, 30);
    ctx.restore();
  }
  
  // Draw source (footer right) - Using sourceObj
  if (sourceObj.text) {
    ctx.save();
    ctx.textAlign = 'right';
    ctx.textBaseline = 'bottom';
    ctx.fillStyle = sourceObj.color;
    ctx.font = `bold ${35 * sourceObj.scale}px "${sourceObj.font}"`;
    if (sourceObj.shadow !== false) {
      ctx.shadowColor = 'rgba(0,0,0,.65)';
      ctx.shadowBlur = sourceShadowBlur;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }
    ctx.fillText('‡¶∏‡ßã‡¶∞‡ßç‡¶∏: ' + sourceObj.text, canvas.width - 30, canvas.height - 110);
    ctx.restore();
  }

  // Texts
  texts.forEach(tb => {
    ctx.save();
    ctx.translate(tb.x, tb.y);
    ctx.rotate(tb.rotation);
    ctx.scale(tb.scale, tb.scale);

    ctx.textAlign = 'center';
    ctx.fillStyle = tb.color;
    if (tb.shadow !== false) {
      ctx.shadowColor = 'rgba(0,0,0,.65)';
      ctx.shadowBlur = textShadowBlur;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }
    ctx.font = `700 ${baseFontPx}px "${tb.font}"`;

    wrapTextScaled(ctx, tb.text, 0, 0, usableWidth, baseLineH, tb.scale);
    ctx.restore();
  });

  // Preview text (drawn last, semi-transparent for preview feel)
  if (previewText) {
    ctx.save();
    ctx.globalAlpha = 0.7; // Semi-transparent for preview
    ctx.translate(previewText.x, previewText.y);
    ctx.rotate(previewText.rotation);
    ctx.scale(previewText.scale, previewText.scale);

    ctx.textAlign = 'center';
    ctx.fillStyle = previewText.color;
    if (previewText.shadow !== false) {
      ctx.shadowColor = 'rgba(0,0,0,.65)';
      ctx.shadowBlur = textShadowBlur;
    } else {
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
    }
    ctx.font = `700 ${baseFontPx}px "${previewText.font}"`;

    wrapTextScaled(ctx, previewText.text, 0, 0, usableWidth, baseLineH, previewText.scale);
    ctx.restore();
  }

  // Free transform handles
  if (showHandles && selectedType) {
    let obj, isText, halfWW, halfWH, unscaledW, unscaledH, s;
    if (selectedType === 'text') {
      obj = selected;
      isText = true;
      const dims = getWrappedTextDimensions(obj);
      halfWW = dims.width / 2;
      halfWH = dims.height / 2;
      s = obj.scale;
      unscaledW = dims.width / s;
      unscaledH = dims.height / s;
    } else {
      obj = images[selectedImgIndex];
      isText = false;
      const iw = obj.img.width;
      const ih = obj.img.height;
      halfWW = iw * obj.scale / 2;
      halfWH = ih * obj.scale / 2;
      s = obj.scale;
      unscaledW = iw;
      unscaledH = ih;
    }
    ctx.save();
    ctx.translate(obj.x, obj.y);
    ctx.rotate(obj.rotation);
    // bbox
    ctx.strokeStyle = 'rgba(110,168,254,0.8)';
    ctx.lineWidth = 2;
    ctx.strokeRect(-halfWW, -halfWH, 2 * halfWW, 2 * halfWH);
    // corners
    ctx.fillStyle = 'rgba(110,168,254,0.9)';
    const hR = 6;
    const corners = [
      [-halfWW, -halfWH],
      [halfWW, -halfWH],
      [halfWW, halfWH],
      [-halfWW, halfWH]
    ];
    corners.forEach(([cx, cy]) => {
      ctx.beginPath();
      ctx.arc(cx, cy, hR, 0, 2 * Math.PI);
      ctx.fill();
    });
    // rotation handle
    const rotX = 0;
    const rotY = -halfWH - rotOffset;
    ctx.strokeStyle = 'rgba(110,168,254,0.6)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, -halfWH);
    ctx.lineTo(rotX, rotY);
    ctx.stroke();
    ctx.fillStyle = 'rgba(110,168,254,0.9)';
    ctx.beginPath();
    ctx.arc(rotX, rotY, hR, 0, 2 * Math.PI);
    ctx.fill();
    ctx.restore();
  }

  // Update selection display after draw
  updateSelectionDisplay();
  updateTextBounds(); // Cache bounds after drawing texts
}

/* ========= Pointer Events ========= */
canvas.addEventListener('pointerdown', (e) => {
  const p = deviceToCanvas(e.clientX, e.clientY);
  let hitSomething = false;
  if (showHandles && selectedType) {
    const isText = selectedType === 'text';
    const obj = isText ? selected : images[selectedImgIndex];
    const s = obj.scale;
    const th = obj.rotation;
    const cos = Math.cos(th);
    const sin = Math.sin(th);
    let dx = p.x - obj.x;
    let dy = p.y - obj.y;
    let itx = cos * dx + sin * dy;
    let ity = -sin * dx + cos * dy;
    let local_x = itx / s;
    let local_y = ity / s;
    const unscaled = getUnscaledDims(obj, isText);
    const halfUnW = unscaled.width / 2;
    const halfUnH = unscaled.height / 2;
    const localHR = handleRadius / s;
    // rotation handle
    const localOffset = rotOffset / s;
    const lrx = 0;
    const lry = -halfUnH - localOffset;
    let distRot = Math.hypot(local_x - lrx, local_y - lry);
    if (distRot < localHR) {
      transformMode = 'rotate';
      prevAngle = Math.atan2(local_y, local_x);
      currentObj = obj;
      isCurrentText = isText;
      hitSomething = true;
    } else {
      // corners for scale
      const corners = [
        {lx: -halfUnW, ly: -halfUnH},
        {lx: halfUnW, ly: -halfUnH},
        {lx: halfUnW, ly: halfUnH},
        {lx: -halfUnW, ly: halfUnH}
      ];
      for (let corner of corners) {
        let d = Math.hypot(local_x - corner.lx, local_y - corner.ly);
        if (d < localHR) {
          transformMode = 'scale';
          startScale = obj.scale;
          startRadial = Math.hypot(local_x, local_y);
          currentObj = obj;
          isCurrentText = isText;
          hitSomething = true;
          break;
        }
      }
    }
    if (!hitSomething) {
      // inside for move
      if (Math.abs(local_x) < halfUnW && Math.abs(local_y) < halfUnH) {
        transformMode = 'move';
        dragStartX = p.x;
        dragStartY = p.y;
        startObjX = obj.x;
        startObjY = obj.y;
        currentObj = obj;
        isCurrentText = isText;
        hitSomething = true;
      }
    }
  }
  if (!hitSomething) {
    // deselect
    selected = null;
    selectedType = null;
    selectedImgIndex = -1;
    showHandles = false;
    transformMode = null;
    currentObj = null;
    // check for new selection - texts first using cached bounds
    for (let i = texts.length - 1; i >= 0; i--) {
      const bound = textBounds[i];
      if (bound && p.x > bound.x && p.x < bound.x + bound.width &&
          p.y > bound.y && p.y < bound.y + bound.height) {
        selected = texts[i];
        selectedType = 'text';
        selectedImgIndex = -1;
        transformMode = 'move';
        dragStartX = p.x;
        dragStartY = p.y;
        startObjX = selected.x;
        startObjY = selected.y;
        currentObj = selected;
        isCurrentText = true;
        showHandles = false;
        hitSomething = true;
        break;
      }
    }
    if (!hitSomething) {
      // images
      for (let i = images.length - 1; i >= 0; i--) {
        if (isPointInObject(p, images[i], false)) {
          selectedImgIndex = i;
          selectedType = 'image';
          selected = null;
          transformMode = 'move';
          dragStartX = p.x;
          dragStartY = p.y;
          startObjX = images[i].x;
          startObjY = images[i].y;
          currentObj = images[i];
          isCurrentText = false;
          showHandles = false;
          hitSomething = true;
          break;
        }
      }
    }
  }
  if (hitSomething) {
    updateSelectionDisplay();
  }
  scheduleRedraw();
  e.preventDefault();
});

canvas.addEventListener('pointermove', (e) => {
  if (!transformMode || !currentObj) return;
  const isText = isCurrentText;
  const currentP = deviceToCanvas(e.clientX, e.clientY);
  const s = currentObj.scale;
  const th = currentObj.rotation;
  const cos = Math.cos(th);
  const sin = Math.sin(th);
  let dx = currentP.x - currentObj.x;
  let dy = currentP.y - currentObj.y;
  let itx = cos * dx + sin * dy;
  let ity = -sin * dx + cos * dy;
  let local_x = itx / s;
  let local_y = ity / s;
  if (transformMode === 'move') {
    const delX = currentP.x - dragStartX;
    const delY = currentP.y - dragStartY;
    currentObj.x = startObjX + delX;
    currentObj.y = startObjY + delY;
  } else if (transformMode === 'scale') {
    const currentRadial = Math.hypot(local_x, local_y);
    let newScale = startScale * (currentRadial / startRadial);
    newScale = clamp(newScale, 0.1, 8);
    currentObj.scale = newScale;
    if (isText) updateTextBounds();
  } else if (transformMode === 'rotate') {
    const currentAngle = Math.atan2(local_y, local_x);
    const delta = currentAngle - prevAngle;
    currentObj.rotation += delta;
    prevAngle = currentAngle;
  }
  scheduleRedraw();
});

['pointerup','pointerleave','pointercancel'].forEach(ev => {
  canvas.addEventListener(ev, () => { 
    transformMode = null;
    currentObj = null;
    isCurrentText = false;
    scheduleRedraw();
  });
});

/* ========= Touch: pinch-to-zoom ========= */
canvas.addEventListener('touchstart', (e) => {
  if(e.touches.length === 1){ return; }
  if(e.touches.length === 2){
    e.preventDefault();
    const p1 = getTouchCanvasPos(e.touches[0]);
    const p2 = getTouchCanvasPos(e.touches[1]);
    const cx = (p1.x + p2.x)/2, cy = (p1.y + p2.y)/2;

    // Decide target based on pinch center
    pinchTarget = 'background';
    // try hit text first (since on top)
    for(let i=texts.length-1;i>=0;i--){
      const bound = textBounds[i];
      if (bound && cx > bound.x && cx < bound.x + bound.width &&
          cy > bound.y && cy < bound.y + bound.height) {
        pinchTarget = 'text';
        selected = texts[i];
        selectedType = 'text';
        break;
      }
    }
    // try hit image
    if (pinchTarget === 'background') {
      for(let i=images.length-1;i>=0;i--){
        if(isPointInObject({x:cx,y:cy}, images[i], false)){
          pinchTarget = 'selectedImg';
          selectedImgIndex = i;
          selectedType = 'image';
          break;
        }
      }
    }
    pinchStartDist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    if(pinchTarget === 'text'){
      textPinchStartScale = selected.scale;
      textPinchStartDist  = pinchStartDist;
    } else if (pinchTarget === 'selectedImg') {
      selectedImgPinchStartScale = images[selectedImgIndex].scale;
      selectedImgPinchStartDist = pinchStartDist;
    } else {
      pinchStartScale = 1; // No scale for background
      pinchCenter = {x:cx, y:cy};
      imgOffsetFromCenter = { x: 0, y: 0 };
    }
    updateSelectionDisplay();
    scheduleRedraw();
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  if(e.touches.length !== 2) return;
  e.preventDefault();
  const p1 = getTouchCanvasPos(e.touches[0]);
  const p2 = getTouchCanvasPos(e.touches[1]);
  const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);

  if(pinchTarget === 'text' && selectedType === 'text' && selected){
    const factor = dist / textPinchStartDist;
    selected.scale = clamp(textPinchStartScale * factor, 0.1, 8);
    updateTextBounds();
    scheduleRedraw();
  } else if (pinchTarget === 'selectedImg' && selectedType === 'image' && selectedImgIndex >= 0) {
    const factor = dist / selectedImgPinchStartDist;
    images[selectedImgIndex].scale = clamp(selectedImgPinchStartScale * factor, 0.1, 8);
    scheduleRedraw();
  } else if (pinchTarget === 'background') {
    // No action for background pinch
  }
}, {passive:false});

/* ========= Zoom buttons ========= */
zoomInBtn.addEventListener('click', () => {
  if(selectedType === 'text' && selected){ 
    selected.scale = clamp(selected.scale * 1.1, 0.1, 8); 
    updateTextBounds();
  } else if (selectedType === 'image' && selectedImgIndex >= 0) { 
    images[selectedImgIndex].scale = clamp(images[selectedImgIndex].scale * 1.1, 0.1, 8); 
  }
  scheduleRedraw();
});

zoomOutBtn.addEventListener('click', () => {
  if(selectedType === 'text' && selected){ 
    selected.scale = clamp(selected.scale / 1.1, 0.1, 8); 
    updateTextBounds();
  } else if (selectedType === 'image' && selectedImgIndex >= 0) { 
    images[selectedImgIndex].scale = clamp(images[selectedImgIndex].scale / 1.1, 0.1, 8); 
  }
  scheduleRedraw();
});

function updateZoomLabel(){
  zoomLabel.textContent = `Image Zoom: 100%`; // Simplified, as multiple images have individual scales
}

/* ========= Edit/Delete icons ========= */
editBtn.addEventListener('click', () => {
  if(!selected || selectedType !== 'text') return;
  const t = prompt('Edit text:', selected.text);
  if(t !== null){
    selected.text = t;
    updateTextBounds(); // Update bounds after edit
    scheduleRedraw();
  }
});
delBtn.addEventListener('click', () => {
  if(!selected || selectedType !== 'text') return;
  if (confirm('Are you sure you want to delete this text?')) {
    texts = texts.filter(tb => tb !== selected);
    selected = null;
    selectedType = null;
    showHandles = false;
    updateTextBounds(); // Update after delete
    scheduleRedraw();
  }
});

/* ========= Download ========= */
downloadBtn.addEventListener('click', () => {
  const a = document.createElement('a');
  a.download = 'poster.png';
  a.href = canvas.toDataURL('image/png', 0.9); // Slight compression
  a.click();
});
</script>
</body>
</html>