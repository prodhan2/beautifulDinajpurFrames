<!DOCTYPE html>
<html lang="bn">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>News Poster Editor with Download</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #f5f5f5;
    padding: 20px;
    text-align: center;
    margin: 0;
  }

  .poster {
    width: 100%;
    max-width: 400px;
    border: 5px solid green;
    margin: auto;
    background: white;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    position: relative;
  }

  .image-container {
    width: 100%;
    height: 250px;
    overflow: hidden;
    position: relative;
    cursor: grab;
  }
  
  .poster img.uploaded {
    width: 100%;
    height: 100%;
    object-fit: contain; /* Changed from cover to contain to show full image */
    display: block;
    transform-origin: center center;
    transition: transform 0.1s ease;
    background-color: #f0f0f0; /* Background for images with transparency */
  }

  .draggable-group {
    position: absolute;
    top: 260px; /* শুরুতে image এর নিচে */
    left: 0;
    width: 100%;
    cursor: grab;
    z-index: 10;
  }

  .separator {
    position: relative;
    height: 80px; /* Separator er total height boro kora holo */
    margin: 0;
}

.separator::before {
    content: "";
    position: absolute;
    top: 50%;
    left: 0;
    width: 100%; /* line er width */
    height: 15px; /* line er mota boro kora holo */
    background: green;
    transform: translateY(-50%);
    border-radius: 3px; /* line ke thoda rounded korar jonno */
}


  .logo-circle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid green;
    background: white;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .logo-circle img {
    width: 65px;
    height: 65px;
    border-radius: 50%;
    object-fit: cover;
  }

  .headline {
    font-size: 22px;
    font-weight: bold;
    color: red;
    margin: 10px;
    line-height: 1.4;
    word-wrap: break-word;
    position: relative;
    top: 0;
  }

  .content-area {
    background: white;
    min-height: 100px;
    position: relative;
    overflow: hidden;
    transition: min-height 0.3s ease;
  }

  .footer {
    display: flex;
    justify-content: space-between;
    font-size: 14px;
    padding: 10px;
    color: white; /* Changed to white */
    background-color: green; /* Added green background */
  }

  .controls {
    margin-bottom: 20px;
    padding: 10px;
  }

  input {
    margin: 5px;
    padding: 8px;
    width: 90%;
    max-width: 300px;
    box-sizing: border-box;
  }
  
  .zoom-controls {
    margin-top: 10px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    gap: 5px;
  }
  
  .zoom-controls button {
    padding: 8px 12px;
    margin: 5px;
    cursor: pointer;
    background: green;
    color: white;
    border: none;
    border-radius: 4px;
  }
  
  .download-btn {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 12px 24px;
    margin-top: 15px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    transition: background 0.3s;
  }
  
  .download-btn:hover {
    background: #45a049;
  }
  
  .expand-controls {
    margin: 10px 0;
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  
  .expand-controls button {
    padding: 8px 15px;
    background: #4CAF50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  
  /* Cropping Modal Styles */
  .crop-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 100;
    justify-content: center;
    align-items: center;
  }
  
  .crop-container {
    background: white;
    padding: 20px;
    border-radius: 8px;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow: auto;
  }
  
  .crop-area {
    position: relative;
    width: 100%;
    height: 300px;
    overflow: hidden;
    margin-bottom: 15px;
    background: #f0f0f0;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  
  #cropImage {
    max-width: 100%;
    max-height: 100%;
    display: block;
  }
  
  .crop-box {
    position: absolute;
    top: 50px;
    left: 50px;
    width: 200px;
    height: 200px;
    border: 2px dashed #fff;
    box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
    cursor: move;
  }
  
  .crop-handle {
    position: absolute;
    width: 15px;
    height: 15px;
    background: #fff;
    border: 1px solid #000;
  }
  
  .handle-nw { top: -8px; left: -8px; cursor: nw-resize; }
  .handle-ne { top: -8px; right: -8px; cursor: ne-resize; }
  .handle-sw { bottom: -8px; left: -8px; cursor: sw-resize; }
  .handle-se { bottom: -8px; right: -8px; cursor: se-resize; }
  
  .crop-controls {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 15px;
  }
  
  .crop-controls button {
    padding: 8px 15px;
    cursor: pointer;
    background: green;
    color: white;
    border: none;
    border-radius: 4px;
  }
  
  .crop-controls button.cancel {
    background: #ccc;
    color: #333;
  }
  
  .crop-instructions {
    margin-top: 10px;
    font-size: 14px;
    color: #666;
    text-align: center;
  }

  /* Mobile-specific styles */
  @media (max-width: 480px) {
    .poster {
      width: 100%;
      max-width: 350px;
    }
    
    .image-container {
      height: 200px;
    }
    
    .headline {
      font-size: 18px;
    }
    
    .footer {
      flex-direction: column;
      text-align: center;
      gap: 5px;
    }
    
    .zoom-controls {
      flex-direction: column;
      align-items: center;
    }
    
    .zoom-controls button {
      width: 80%;
    }
    
    .expand-controls {
      flex-direction: column;
      align-items: center;
    }
    
    .expand-controls button {
      width: 80%;
    }
  }
</style>
</head>
<body>
<h2>News Poster Live Preview (Draggable Separator + Logo + Zoomable Image)</h2>

<div class="controls">
  <input type="file" id="imageInput" accept="image/*"><br>
  <input type="text" id="headlineInput" placeholder="Enter Headline"><br>
  <input type="text" id="creditInput" placeholder="Enter Credits"><br>
  <div class="zoom-controls">
    <button id="zoomIn">Zoom In</button>
    <button id="zoomOut">Zoom Out</button>
    <button id="resetImage">Reset Image</button>
    <button id="cropImageBtn">Crop Image</button>
  </div>
  <div class="expand-controls">
    <button id="expandContent">Expand White Area</button>
    <button id="shrinkContent">Shrink White Area</button>
  </div>
  <button id="downloadBtn" class="download-btn">Download Poster</button>
</div>

<div class="poster" id="poster">
  <!-- Uploaded Image Container -->
  <div class="image-container" id="imageContainer">
    <img id="uploadedImage" class="uploaded" src="https://via.placeholder.com/400x250" alt="Uploaded Image">
  </div>

  <!-- Draggable Separator + Logo -->
  <div class="draggable-group" id="draggableGroup">
    <div class="separator">
      <div class="logo-circle">
        <img src="/dinlogo.png" alt="Logo">
      </div>
    </div>
  </div>

  <!-- Content Area (White Background) -->
  <div class="content-area" id="contentArea">
    <!-- Headline BELOW separator -->
    <div class="headline" id="headline">Your Headline Here</div>
  </div>

  <!-- Footer -->
  <div class="footer">
    <div id="date">Date: </div>
    <div id="credit">Credits: Your Name</div>
  </div>
</div>

<!-- Cropping Modal -->
<div class="crop-modal" id="cropModal">
  <div class="crop-container">
    <h3>Crop Image</h3>
    <div class="crop-area" id="cropArea">
      <img id="cropImage" src="" alt="Image to crop">
      <div class="crop-box" id="cropBox">
        <div class="crop-handle handle-nw"></div>
        <div class="crop-handle handle-ne"></div>
        <div class="crop-handle handle-sw"></div>
        <div class="crop-handle handle-se"></div>
      </div>
    </div>
    <div class="crop-instructions">
      Drag the box to move, drag handles to resize
    </div>
    <div class="crop-controls">
      <button id="applyCrop">Apply Crop</button>
      <button id="cancelCrop" class="cancel">Cancel</button>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
  // Auto date
  const today = new Date();
  const formattedDate = today.toLocaleDateString();
  document.getElementById("date").textContent = "Date: " + formattedDate;

  // Image upload
  document.getElementById("imageInput").addEventListener("change", function(event) {
    const file = event.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        document.getElementById("uploadedImage").src = e.target.result;
        // Reset image position and scale after upload
        resetImagePosition();
      };
      reader.readAsDataURL(file);
    }
  });

  // Headline live update
  document.getElementById("headlineInput").addEventListener("input", function() {
    document.getElementById("headline").textContent = this.value;
  });

  // Credit live update
  document.getElementById("creditInput").addEventListener("input", function() {
    document.getElementById("credit").textContent = "Credits: " + this.value;
  });

  // Expand/Shrink white content area
  const contentArea = document.getElementById('contentArea');
  let contentHeight = 100; // Default height in pixels
  
  document.getElementById('expandContent').addEventListener('click', function() {
    contentHeight += 50;
    contentArea.style.minHeight = contentHeight + 'px';
  });
  
  document.getElementById('shrinkContent').addEventListener('click', function() {
    if (contentHeight > 50) {
      contentHeight -= 50;
      contentArea.style.minHeight = contentHeight + 'px';
    }
  });

  // Draggable functionality for separator
  const draggable = document.getElementById('draggableGroup');
  let offsetY = 0;
  let isDraggingSeparator = false;

  draggable.addEventListener('mousedown', function(e) {
    isDraggingSeparator = true;
    offsetY = e.clientY - draggable.getBoundingClientRect().top;
    draggable.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', function(e) {
    if (isDraggingSeparator) {
      const posterTop = document.getElementById('poster').getBoundingClientRect().top;
      let newTop = e.clientY - posterTop - offsetY;
      if(newTop < 0) newTop = 0;
      if(newTop > 250) newTop = 250; // restrict within poster
      draggable.style.top = newTop + 'px';
    }
  });

  document.addEventListener('mouseup', function() {
    isDraggingSeparator = false;
    draggable.style.cursor = 'grab';
  });

  // Touch events for mobile
  draggable.addEventListener('touchstart', function(e) {
    e.preventDefault();
    isDraggingSeparator = true;
    offsetY = e.touches[0].clientY - draggable.getBoundingClientRect().top;
  });

  document.addEventListener('touchmove', function(e) {
    if (isDraggingSeparator) {
      const posterTop = document.getElementById('poster').getBoundingClientRect().top;
      let newTop = e.touches[0].clientY - posterTop - offsetY;
      if(newTop < 0) newTop = 0;
      if(newTop > 250) newTop = 250;
      draggable.style.top = newTop + 'px';
    }
  });

  document.addEventListener('touchend', function() {
    isDraggingSeparator = false;
  });

  // Image zoom and pan functionality
  const imageContainer = document.getElementById('imageContainer');
  const uploadedImage = document.getElementById('uploadedImage');
  let scale = 1;
  let posX = 0;
  let posY = 0;
  let isDraggingImage = false;
  let startX, startY, initialPosX, initialPosY;

  // Mouse events for image panning - ALWAYS allow dragging
  imageContainer.addEventListener('mousedown', function(e) {
    isDraggingImage = true;
    startX = e.clientX;
    startY = e.clientY;
    initialPosX = posX;
    initialPosY = posY;
    imageContainer.style.cursor = 'grabbing';
  });

  document.addEventListener('mousemove', function(e) {
    if (!isDraggingImage) return;
    
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    
    // Calculate new position with boundaries
    const imgWidth = uploadedImage.naturalWidth * scale;
    const imgHeight = uploadedImage.naturalHeight * scale;
    const containerWidth = imageContainer.offsetWidth;
    const containerHeight = imageContainer.offsetHeight;
    
    const maxX = Math.max(0, (imgWidth - containerWidth) / 2);
    const maxY = Math.max(0, (imgHeight - containerHeight) / 2);
    
    posX = initialPosX + dx;
    posY = initialPosY + dy;
    
    // Apply boundaries only if zoomed in
    if (scale > 1) {
      posX = Math.min(Math.max(posX, -maxX), maxX);
      posY = Math.min(Math.max(posY, -maxY), maxY);
    } else {
      // Reset to center if not zoomed
      posX = 0;
      posY = 0;
    }
    
    updateImageTransform();
  });

  document.addEventListener('mouseup', function() {
    isDraggingImage = false;
    imageContainer.style.cursor = 'grab';
  });

  // Touch events for mobile
  imageContainer.addEventListener('touchstart', function(e) {
    if (e.touches.length === 1) {
      isDraggingImage = true;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      initialPosX = posX;
      initialPosY = posY;
    } else if (e.touches.length === 2) {
      // Handle pinch zoom
      isDraggingImage = false;
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.clientX - touch1.clientX,
        touch2.clientY - touch1.clientY
      );
      
      // Store initial values for zooming
      imageContainer.dataset.initialDistance = distance;
      imageContainer.dataset.initialScale = scale;
      imageContainer.dataset.midX = (touch1.clientX + touch2.clientX) / 2;
      imageContainer.dataset.midY = (touch1.clientY + touch2.clientY) / 2;
    }
  });

  document.addEventListener('touchmove', function(e) {
    if (isDraggingImage && e.touches.length === 1) {
      const dx = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      
      // Calculate new position with boundaries
      const imgWidth = uploadedImage.naturalWidth * scale;
      const imgHeight = uploadedImage.naturalHeight * scale;
      const containerWidth = imageContainer.offsetWidth;
      const containerHeight = imageContainer.offsetHeight;
      
      const maxX = Math.max(0, (imgWidth - containerWidth) / 2);
      const maxY = Math.max(0, (imgHeight - containerHeight) / 2);
      
      posX = initialPosX + dx;
      posY = initialPosY + dy;
      
      // Apply boundaries only if zoomed in
      if (scale > 1) {
        posX = Math.min(Math.max(posX, -maxX), maxX);
        posY = Math.min(Math.max(posY, -maxY), maxY);
      }
      
      updateImageTransform();
    } else if (e.touches.length === 2) {
      // Handle pinch zoom
      const touch1 = e.touches[0];
      const touch2 = e.touches[1];
      const distance = Math.hypot(
        touch2.clientX - touch1.clientX,
        touch2.clientY - touch1.clientY
      );
      
      const initialDistance = parseFloat(imageContainer.dataset.initialDistance);
      const initialScale = parseFloat(imageContainer.dataset.initialScale);
      const midX = parseFloat(imageContainer.dataset.midX);
      const midY = parseFloat(imageContainer.dataset.midY);
      
      if (initialDistance) {
        const zoom = distance / initialDistance;
        const newScale = Math.min(Math.max(initialScale * zoom, 0.5), 5);
        
        if (newScale !== scale) {
          // Calculate the position relative to the image
          const rect = imageContainer.getBoundingClientRect();
          const relativeX = midX - rect.left;
          const relativeY = midY - rect.top;
          
          const imageX = (relativeX - containerWidth / 2 - posX) / scale;
          const imageY = (relativeY - containerHeight / 2 - posY) / scale;
          
          scale = newScale;
          
          // Adjust position to zoom toward the midpoint
          posX = -(imageX * scale - relativeX + containerWidth / 2);
          posY = -(imageY * scale - relativeY + containerHeight / 2);
          
          // Apply boundaries if zoomed in
          if (scale > 1) {
            const imgWidth = uploadedImage.naturalWidth * scale;
            const imgHeight = uploadedImage.naturalHeight * scale;
            const maxX = Math.max(0, (imgWidth - containerWidth) / 2);
            const maxY = Math.max(0, (imgHeight - containerHeight) / 2);
            
            posX = Math.min(Math.max(posX, -maxX), maxX);
            posY = Math.min(Math.max(posY, -maxY), maxY);
          }
          
          updateImageTransform();
        }
      }
    }
  });

  document.addEventListener('touchend', function() {
    isDraggingImage = false;
    delete imageContainer.dataset.initialDistance;
  });

  // Wheel event for zooming
  imageContainer.addEventListener('wheel', function(e) {
    e.preventDefault();
    
    const rect = imageContainer.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const zoomIntensity = 0.1;
    const wheel = e.deltaY < 0 ? 1 : -1;
    const zoom = Math.exp(wheel * zoomIntensity);
    
    // Calculate new scale with limits
    const newScale = Math.min(Math.max(scale * zoom, 0.5), 5);
    
    if (newScale === scale) return;
    
    // Calculate mouse position relative to image
    const imageX = (mouseX - rect.width / 2 - posX) / scale;
    const imageY = (mouseY - rect.height / 2 - posY) / scale;
    
    scale = newScale;
    
    // Adjust position to zoom toward mouse
    posX = -(imageX * scale - mouseX + rect.width / 2);
    posY = -(imageY * scale - mouseY + rect.height / 2);
    
    // Apply boundaries if zoomed in
    if (scale > 1) {
      const imgWidth = uploadedImage.naturalWidth * scale;
      const imgHeight = uploadedImage.naturalHeight * scale;
      const maxX = Math.max(0, (imgWidth - rect.width) / 2);
      const maxY = Math.max(0, (imgHeight - rect.height) / 2);
      
      posX = Math.min(Math.max(posX, -maxX), maxX);
      posY = Math.min(Math.max(posY, -maxY), maxY);
    }
    
    updateImageTransform();
    imageContainer.style.cursor = 'grab';
  });

  // Button controls
  document.getElementById('zoomIn').addEventListener('click', function() {
    const rect = imageContainer.getBoundingClientRect();
    const mouseX = rect.width / 2;
    const mouseY = rect.height / 2;
    
    // Calculate new scale with limits
    const newScale = Math.min(scale + 0.2, 5);
    
    if (newScale === scale) return;
    
    // Calculate mouse position relative to image
    const imageX = (mouseX - rect.width / 2 - posX) / scale;
    const imageY = (mouseY - rect.height / 2 - posY) / scale;
    
    scale = newScale;
    
    // Adjust position to zoom toward center
    posX = -(imageX * scale - mouseX + rect.width / 2);
    posY = -(imageY * scale - mouseY + rect.height / 2);
    
    // Apply boundaries if zoomed in
    if (scale > 1) {
      const imgWidth = uploadedImage.naturalWidth * scale;
      const imgHeight = uploadedImage.naturalHeight * scale;
      const maxX = Math.max(0, (imgWidth - rect.width) / 2);
      const maxY = Math.max(0, (imgHeight - rect.height) / 2);
      
      posX = Math.min(Math.max(posX, -maxX), maxX);
      posY = Math.min(Math.max(posY, -maxY), maxY);
    }
    
    updateImageTransform();
    imageContainer.style.cursor = 'grab';
  });

  document.getElementById('zoomOut').addEventListener('click', function() {
    const rect = imageContainer.getBoundingClientRect();
    const mouseX = rect.width / 2;
    const mouseY = rect.height / 2;
    
    // Calculate new scale with limits
    const newScale = Math.max(scale - 0.2, 0.5);
    
    if (newScale === scale) return;
    
    // Calculate mouse position relative to image
    const imageX = (mouseX - rect.width / 2 - posX) / scale;
    const imageY = (mouseY - rect.height / 2 - posY) / scale;
    
    scale = newScale;
    
    // Adjust position to zoom toward center
    posX = -(imageX * scale - mouseX + rect.width / 2);
    posY = -(imageY * scale - mouseY + rect.height / 2);
    
    // Reset position if back to normal scale
    if (scale <= 1) {
      const imgWidth = uploadedImage.naturalWidth * scale;
      const imgHeight = uploadedImage.naturalHeight * scale;
      const maxX = Math.max(0, (imgWidth - rect.width) / 2);
      const maxY = Math.max(0, (imgHeight - rect.height) / 2);
      
      posX = Math.min(Math.max(posX, -maxX), maxX);
      posY = Math.min(Math.max(posY, -maxY), maxY);
    }
    
    updateImageTransform();
    imageContainer.style.cursor = scale > 1 ? 'grab' : 'default';
  });

  document.getElementById('resetImage').addEventListener('click', resetImagePosition);

  function updateImageTransform() {
    uploadedImage.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
  }

  function resetImagePosition() {
    scale = 1;
    posX = 0;
    posY = 0;
    updateImageTransform();
    imageContainer.style.cursor = 'default';
  }

  // Image Cropping Functionality - Fixed Implementation
  const cropModal = document.getElementById('cropModal');
  const cropImageBtn = document.getElementById('cropImageBtn');
  const cropImgElement = document.getElementById('cropImage');
  const cropBox = document.getElementById('cropBox');
  const applyCrop = document.getElementById('applyCrop');
  const cancelCrop = document.getElementById('cancelCrop');
  const cropArea = document.getElementById('cropArea');
  
  let cropData = {
    x: 50,
    y: 50,
    width: 200,
    height: 200
  };
  
  let imageAspectRatio = 1;
  let isDraggingCrop = false;
  let isResizingCrop = false;
  let resizeDirection = '';
  let startCropX, startCropY;
  let naturalWidth, naturalHeight;
  
  // Open crop modal
  cropImageBtn.addEventListener('click', function() {
    if (!uploadedImage.src || uploadedImage.src.includes('via.placeholder.com')) {
      alert('Please upload an image first');
      return;
    }
    
    cropImgElement.src = uploadedImage.src;
    cropModal.style.display = 'flex';
    
    // Calculate aspect ratio of the image
    const img = new Image();
    img.onload = function() {
      naturalWidth = img.naturalWidth;
      naturalHeight = img.naturalHeight;
      imageAspectRatio = naturalWidth / naturalHeight;
      
      // Initialize crop box position
      const areaWidth = cropArea.offsetWidth;
      const areaHeight = cropArea.offsetHeight;
      
      // Set initial crop box size based on image aspect ratio
      const boxWidth = Math.min(areaWidth * 0.6, areaHeight * 0.6 * imageAspectRatio);
      const boxHeight = boxWidth / imageAspectRatio;
      
      cropData = {
        x: (areaWidth - boxWidth) / 2,
        y: (areaHeight - boxHeight) / 2,
        width: boxWidth,
        height: boxHeight
      };
      
      updateCropBox();
    };
    img.src = uploadedImage.src;
  });
  
  // Close crop modal
  cancelCrop.addEventListener('click', function() {
    cropModal.style.display = 'none';
  });
  
  // Apply crop
  applyCrop.addEventListener('click', function() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas dimensions to match crop box
    canvas.width = cropData.width;
    canvas.height = cropData.height;
    
    // Calculate scaling factor (original image vs displayed image)
    const img = new Image();
    img.onload = function() {
      // Get the displayed image dimensions
      const displayedWidth = cropImgElement.naturalWidth;
      const displayedHeight = cropImgElement.naturalHeight;
      
      // Calculate the scale between the original image and the displayed image
      const scaleX = naturalWidth / displayedWidth;
      const scaleY = naturalHeight / displayedHeight;
      
      // Calculate the position of the image within the crop area
      const imgX = (cropArea.offsetWidth - displayedWidth) / 2;
      const imgY = (cropArea.offsetHeight - displayedHeight) / 2;
      
      // Calculate the actual crop coordinates relative to the original image
      const cropX = (cropData.x - imgX) * scaleX;
      const cropY = (cropData.y - imgY) * scaleY;
      const cropWidth = cropData.width * scaleX;
      const cropHeight = cropData.height * scaleY;
      
      // Draw cropped portion on canvas
      ctx.drawImage(
        img,
        cropX, cropY, cropWidth, cropHeight,
        0, 0, cropData.width, cropData.height
      );
      
      // Update the image in the poster
      uploadedImage.src = canvas.toDataURL('image/jpeg');
      
      // Reset image position and scale
      resetImagePosition();
      
      // Close modal
      cropModal.style.display = 'none';
    };
    img.src = uploadedImage.src;
  });
  
  // Make crop box draggable and resizable
  cropBox.addEventListener('mousedown', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.target.classList.contains('crop-handle')) {
      isResizingCrop = true;
      resizeDirection = e.target.classList[1].split('-')[1];
    } else {
      isDraggingCrop = true;
    }
    
    startCropX = e.clientX;
    startCropY = e.clientY;
  });
  
  // Touch events for crop box
  cropBox.addEventListener('touchstart', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.target.classList.contains('crop-handle')) {
      isResizingCrop = true;
      resizeDirection = e.target.classList[1].split('-')[1];
    } else {
      isDraggingCrop = true;
    }
    
    startCropX = e.touches[0].clientX;
    startCropY = e.touches[0].clientY;
  });
  
  document.addEventListener('mousemove', function(e) {
    if (!isDraggingCrop && !isResizingCrop) return;
    
    const dx = e.clientX - startCropX;
    const dy = e.clientY - startCropY;
    
    handleCropMove(dx, dy, e.shiftKey);
    
    startCropX = e.clientX;
    startCropY = e.clientY;
  });
  
  document.addEventListener('touchmove', function(e) {
    if (!isDraggingCrop && !isResizingCrop) return;
    
    const dx = e.touches[0].clientX - startCropX;
    const dy = e.touches[0].clientY - startCropY;
    
    handleCropMove(dx, dy, false); // Shift key not available in touch
    
    startCropX = e.touches[0].clientX;
    startCropY = e.touches[0].clientY;
  });
  
  function handleCropMove(dx, dy, maintainAspect) {
    if (isDraggingCrop) {
      // Move the crop box
      cropData.x += dx;
      cropData.y += dy;
      
      // Constrain within image bounds
      const imgX = (cropArea.offsetWidth - cropImgElement.naturalWidth) / 2;
      const imgY = (cropArea.offsetHeight - cropImgElement.naturalHeight) / 2;
      const imgRight = imgX + cropImgElement.naturalWidth;
      const imgBottom = imgY + cropImgElement.naturalHeight;
      
      cropData.x = Math.max(imgX, Math.min(cropData.x, imgRight - cropData.width));
      cropData.y = Math.max(imgY, Math.min(cropData.y, imgBottom - cropData.height));
    } else if (isResizingCrop) {
      // Resize the crop box based on direction
      const minSize = 50;
      
      if (resizeDirection.includes('e')) {
        cropData.width = Math.max(minSize, cropData.width + dx);
      }
      if (resizeDirection.includes('w')) {
        const newWidth = Math.max(minSize, cropData.width - dx);
        cropData.x += cropData.width - newWidth;
        cropData.width = newWidth;
      }
      if (resizeDirection.includes('s')) {
        cropData.height = Math.max(minSize, cropData.height + dy);
      }
      if (resizeDirection.includes('n')) {
        const newHeight = Math.max(minSize, cropData.height - dy);
        cropData.y += cropData.height - newHeight;
        cropData.height = newHeight;
      }
      
      // Maintain aspect ratio if shift key is pressed
      if (maintainAspect) {
        if (resizeDirection.includes('e') || resizeDirection.includes('w')) {
          cropData.height = cropData.width / imageAspectRatio;
        } else if (resizeDirection.includes('s') || resizeDirection.includes('n')) {
          cropData.width = cropData.height * imageAspectRatio;
        }
      }
    }
    
    updateCropBox();
  }
  
  document.addEventListener('mouseup', function() {
    isDraggingCrop = false;
    isResizingCrop = false;
  });
  
  document.addEventListener('touchend', function() {
    isDraggingCrop = false;
    isResizingCrop = false;
  });
  
  function updateCropBox() {
    cropBox.style.left = cropData.x + 'px';
    cropBox.style.top = cropData.y + 'px';
    cropBox.style.width = cropData.width + 'px';
    cropBox.style.height = cropData.height + 'px';
  }
  
  // Close modal if clicked outside
  window.addEventListener('click', function(e) {
    if (e.target === cropModal) {
      cropModal.style.display = 'none';
    }
  });

  // Download functionality
  document.getElementById('downloadBtn').addEventListener('click', function() {
    // Use html2canvas to capture the poster as an image
    html2canvas(document.getElementById('poster')).then(function(canvas) {
      // Convert canvas to data URL
      const imageData = canvas.toDataURL('image/jpeg');
      
      // Create a temporary link element
      const link = document.createElement('a');
      link.href = imageData;
      link.download = 'news-poster.jpg';
      
      // Trigger the download
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    });
  });
</script>
</body>
</html>